/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "wifiBssTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wifiBssTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRCM-WIFI-MGMT-MIB::wifiBssTable is subid 1 of wifiMbss.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1, length: 15
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * wifiBssTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * wifiBssTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiBssTable_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup wifiBssTable undo.
     * set up wifiBssTable undo information, in preparation for a set.
     * Undo storage is in (* wifiBssIASSchedulerType_val_ptr )*
     */

    return rc;
} /* wifiBssTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiBssTable_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> wifiBssTable undo.
     * wifiBssTable undo information, in response to a failed set.
     * Undo storage is in (* wifiBssIASSchedulerType_val_ptr )*
     */

    return rc;
} /* wifiBssTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssTable_undo_cleanup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup wifiBssTable undo.
     * Undo storage is in (* wifiBssIASSchedulerType_val_ptr )*
     */

    return rc;
} /* wifiBssTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiBssTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiBssTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssTable_commit( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit wifiBssTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WIFIBSSENABLE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSENABLE_FLAG; /* clear wifiBssEnable */
       /*
        * TODO:482:o: |-> commit column wifiBssEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSSSID_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSSSID_FLAG; /* clear wifiBssSsid */
       /*
        * TODO:482:o: |-> commit column wifiBssSsid.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssSsid commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssSsid
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSSSID_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSSECURITYMODE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSSECURITYMODE_FLAG; /* clear wifiBssSecurityMode */
       /*
        * TODO:482:o: |-> commit column wifiBssSecurityMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssSecurityMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssSecurityMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSSECURITYMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSCLOSEDNETWORK_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSCLOSEDNETWORK_FLAG; /* clear wifiBssClosedNetwork */
       /*
        * TODO:482:o: |-> commit column wifiBssClosedNetwork.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssClosedNetwork commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssClosedNetwork
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSCLOSEDNETWORK_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSACCESSMODE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSACCESSMODE_FLAG; /* clear wifiBssAccessMode */
       /*
        * TODO:482:o: |-> commit column wifiBssAccessMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssAccessMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssAccessMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSACCESSMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSMAXASSOCIATIONSLIMIT_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSMAXASSOCIATIONSLIMIT_FLAG; /* clear wifiBssMaxAssociationsLimit */
       /*
        * TODO:482:o: |-> commit column wifiBssMaxAssociationsLimit.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssMaxAssociationsLimit commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssMaxAssociationsLimit
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSMAXASSOCIATIONSLIMIT_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSOPMODECAPREQUIRED_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSOPMODECAPREQUIRED_FLAG; /* clear wifiBssOpmodeCapRequired */
       /*
        * TODO:482:o: |-> commit column wifiBssOpmodeCapRequired.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssOpmodeCapRequired commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssOpmodeCapRequired
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSOPMODECAPREQUIRED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSPROTECTEDMGMTFRAMES_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSPROTECTEDMGMTFRAMES_FLAG; /* clear wifiBssProtectedMgmtFrames */
       /*
        * TODO:482:o: |-> commit column wifiBssProtectedMgmtFrames.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssProtectedMgmtFrames commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssProtectedMgmtFrames
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSPROTECTEDMGMTFRAMES_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSPUBLICACCESSMODE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSPUBLICACCESSMODE_FLAG; /* clear wifiBssPublicAccessMode */
       /*
        * TODO:482:o: |-> commit column wifiBssPublicAccessMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssPublicAccessMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssPublicAccessMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSPUBLICACCESSMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSMFBPROBERESPONSE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSMFBPROBERESPONSE_FLAG; /* clear wifiBssMfbProbeResponse */
       /*
        * TODO:482:o: |-> commit column wifiBssMfbProbeResponse.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssMfbProbeResponse commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssMfbProbeResponse
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSMFBPROBERESPONSE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSACCESSTABLECLEAR_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSACCESSTABLECLEAR_FLAG; /* clear wifiBssAccessTableClear */
       /*
        * TODO:482:o: |-> commit column wifiBssAccessTableClear.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssAccessTableClear commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssAccessTableClear
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSACCESSTABLECLEAR_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSIASSCHEDULERENABLE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSIASSCHEDULERENABLE_FLAG; /* clear wifiBssIASSchedulerEnable */
       /*
        * TODO:482:o: |-> commit column wifiBssIASSchedulerEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssIASSchedulerEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssIASSchedulerEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSIASSCHEDULERENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSIASSCHEDULERTYPE_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSIASSCHEDULERTYPE_FLAG; /* clear wifiBssIASSchedulerType */
       /*
        * TODO:482:o: |-> commit column wifiBssIASSchedulerType.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssTable column wifiBssIASSchedulerType commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssIASSchedulerType
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSIASSCHEDULERTYPE_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* wifiBssTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiBssTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiBssTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssTable_undo_commit( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo wifiBssTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* wifiBssTable_undo_commit */

/*
 * TODO:440:M: Implement wifiBssTable node value checks.
 * TODO:450:M: Implement wifiBssTable undo functions.
 * TODO:460:M: Implement wifiBssTable set functions.
 * TODO:480:M: Implement wifiBssTable commit functions.
 */
/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssEnable
 * wifiBssEnable is subid 2 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.2
 * Description:
Enables or disables this service set.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssEnable_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssEnable_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssEnable value.
     */

    return MFD_SUCCESS; /* wifiBssEnable value not illegal */
} /* wifiBssEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssEnable_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssEnable undo.
     */
    /*
     * copy wifiBssEnable data
     * set rowreq_ctx->undo->wifiBssEnable from rowreq_ctx->data.wifiBssEnable
     */
    rowreq_ctx->undo->wifiBssEnable = rowreq_ctx->data.wifiBssEnable;


    return MFD_SUCCESS;
} /* wifiBssEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssEnable_val
 *        A long containing the new value.
 */
int
wifiBssEnable_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssEnable_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssEnable value.
     * set wifiBssEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssEnable = wifiBssEnable_val;

    return MFD_SUCCESS;
} /* wifiBssEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssEnable_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssEnable undo.
     */
    /*
     * copy wifiBssEnable data
     * set rowreq_ctx->data.wifiBssEnable from rowreq_ctx->undo->wifiBssEnable
     */
    rowreq_ctx->data.wifiBssEnable = rowreq_ctx->undo->wifiBssEnable;

    
    return MFD_SUCCESS;
} /* wifiBssEnable_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssSsid
 * wifiBssSsid is subid 3 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.3
 * Description:
Controls and reflects the service set identifier for this BSS.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 32;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 32)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssSsid_val_ptr
 *        A char containing the new value.
 * @param wifiBssSsid_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiBssSsid_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.wifiBssSsid).
 *    The length is in (one of) the range set(s):  0 - 32
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssSsid_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, char *wifiBssSsid_val_ptr,  size_t wifiBssSsid_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSsid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiBssSsid_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wifiBssSsid value.
     */

    return MFD_SUCCESS; /* wifiBssSsid value not illegal */
} /* wifiBssSsid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssSsid_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSsid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssSsid undo.
     */
    /*
     * copy wifiBssSsid and wifiBssSsid_len data
     * set rowreq_ctx->undo->wifiBssSsid from rowreq_ctx->data.wifiBssSsid
     */
    memcpy( rowreq_ctx->undo->wifiBssSsid, rowreq_ctx->data.wifiBssSsid,
            (rowreq_ctx->data.wifiBssSsid_len * sizeof(rowreq_ctx->undo->wifiBssSsid[0])));
    rowreq_ctx->undo->wifiBssSsid_len = rowreq_ctx->data.wifiBssSsid_len;


    return MFD_SUCCESS;
} /* wifiBssSsid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssSsid_val_ptr
 *        A char containing the new value.
 * @param wifiBssSsid_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiBssSsid_val_ptr
 */
int
wifiBssSsid_set( wifiBssTable_rowreq_ctx *rowreq_ctx, char *wifiBssSsid_val_ptr,  size_t wifiBssSsid_val_ptr_len )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSsid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiBssSsid_val_ptr);

    /*
     * TODO:461:M: |-> Set wifiBssSsid value.
     * set wifiBssSsid value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.wifiBssSsid, wifiBssSsid_val_ptr, wifiBssSsid_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.wifiBssSsid_len = wifiBssSsid_val_ptr_len / sizeof(wifiBssSsid_val_ptr[0]);

    return MFD_SUCCESS;
} /* wifiBssSsid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssSsid_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSsid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssSsid undo.
     */
    /*
     * copy wifiBssSsid and wifiBssSsid_len data
     * set rowreq_ctx->data.wifiBssSsid from rowreq_ctx->undo->wifiBssSsid
     */
    memcpy( rowreq_ctx->data.wifiBssSsid, rowreq_ctx->undo->wifiBssSsid,
            (rowreq_ctx->undo->wifiBssSsid_len * sizeof(rowreq_ctx->data.wifiBssSsid[0])));
    rowreq_ctx->data.wifiBssSsid_len = rowreq_ctx->undo->wifiBssSsid_len;

    
    return MFD_SUCCESS;
} /* wifiBssSsid_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssSecurityMode
 * wifiBssSecurityMode is subid 4 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.4
 * Description:
Security mode may be chosen from Disable, WEP, WPA-PSK, WPA2-PSK,
         WPA-Enterprise, WPA2-Enterprise or RADIUS-WEP.  All devices on the 
         network must use the same security mode in order to communicate.

         If set to disabled(0):
            Open system. No authentication or encryption.

         If set to wep(1) then the following parameters must be set:
            Default Transmit Key (wifiBssWepDefaultKey):
                Choose which Key to use.
            WEP Key Bit (wifiBssWepEncryptionMode):
                May select from 64-Bit or 128-Bit encryption.
            Passphrase (wifiBssWepPassPhrase):
                Enter a passphrase consisting of any keyboard character
                to be used to generate a hex WEP key.
            Key 1-4 (wifiBssWep64BitKeyTable or wifiBssWep128BitKeyTable):
                Enter a WEP key manually. Must use only hex character (0-9 and A-F).
                64-bit WEP requires 10 hex characters, 128-Bit WEP requires the use of
                26 hex characters.
                
         If set to wpaPsk(2) then the following parameters must be set:
            WPA Algorithm (wifiBssWpaAlgorithm):
                TKIP or AES.
            WPA Pre-Shared Key (wifiBssWpaPreSharedKey):
                Choose a unique key to authenticate with other devices on the network.
                The Pre-Shared Key must be between 8 and 63 characters in length.
            Group Key Renewal (wifiBssWpaGroupRekeyInterval):
                This settings determines how often the group key changes.

         If set to wpa2Psk(3) then the following parameters must be set:
            WPA2 Algorithm (wifiBssWpaAlgorithm):
                AES or TKIP+AES.
            WPA2 Pre-Shared Key (wifiBssWpaPreSharedKey):
                Choose a unique key to authenticate with other devices on the network.
                The Pre-Shared Key must be between 8 and 63 characters in length.
            Group Key Renewal (wifiBssWpaGroupRekeyInterval):
                This settings determines how often the group key changes.
                
         If set to wpaEnterprise(4) then the following parameters must be set:
            WPA Algorithm (wifiBssWpaAlgorithm):
                TKIP or AES.
            RADIUS Server Address (wifiBssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (wifiBssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (wifiBssRadiusKey):
                The shared secret set on the RADIUS server.
            Key Renewal Timeout (wifiBssRadiusReAuthInterval):
                Determines how often the keys should be renewed.
                
         If set to wpa2Enterprise(5) then the following parameters must be set:
            WPA2 Algorithm (wifiBssWpaAlgorithm):
                AES or TKIP+AES.
            RADIUS Server Address (wifiBssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (wifiBssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (wifiBssRadiusKey):
                The shared secret set on the RADIUS server.
            Key Renewal Timeout (wifiBssRadiusReAuthInterval):
                Determines how often the keys should be renewed.
                
         If set to radiusWep(6) then the following parameters must be set:
            RADIUS Server Address (wifiBssRadiusAddressType / wifiBssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (wifiBssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (wifiBssRadiusKey):
                The shared secret set on the RADIUS server.
            Default Transmit Key (wifiBssWepDefaultKey):
                Choose which Key to use.
            WEP Key Bit (wifiBssWepEncryptionMode):
                May select from 64-Bit or 128-Bit encryption.
            Passphrase (wifiBssWepPassPhrase):
                Enter a passphrase con
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 6/16. Values:  disabled(0), wep(1), wpaPsk(2), wpa2Psk(3), wpaEnterprise(4), wpa2Enterprise(5), radiusWep(6), wpaWpa2Psk(7), wpaWpa2Enterprise(8)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssSecurityMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  disabled(0), wep(1), wpaPsk(2), wpa2Psk(3), wpaEnterprise(4), wpa2Enterprise(5), radiusWep(6), wpaWpa2Psk(7), wpaWpa2Enterprise(8)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssSecurityMode_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssSecurityMode_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSecurityMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssSecurityMode value.
     */

    return MFD_SUCCESS; /* wifiBssSecurityMode value not illegal */
} /* wifiBssSecurityMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssSecurityMode_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSecurityMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssSecurityMode undo.
     */
    /*
     * copy wifiBssSecurityMode data
     * set rowreq_ctx->undo->wifiBssSecurityMode from rowreq_ctx->data.wifiBssSecurityMode
     */
    rowreq_ctx->undo->wifiBssSecurityMode = rowreq_ctx->data.wifiBssSecurityMode;


    return MFD_SUCCESS;
} /* wifiBssSecurityMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssSecurityMode_val
 *        A long containing the new value.
 */
int
wifiBssSecurityMode_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssSecurityMode_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSecurityMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssSecurityMode value.
     * set wifiBssSecurityMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssSecurityMode = wifiBssSecurityMode_val;

    return MFD_SUCCESS;
} /* wifiBssSecurityMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssSecurityMode_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssSecurityMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssSecurityMode undo.
     */
    /*
     * copy wifiBssSecurityMode data
     * set rowreq_ctx->data.wifiBssSecurityMode from rowreq_ctx->undo->wifiBssSecurityMode
     */
    rowreq_ctx->data.wifiBssSecurityMode = rowreq_ctx->undo->wifiBssSecurityMode;

    
    return MFD_SUCCESS;
} /* wifiBssSecurityMode_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssClosedNetwork
 * wifiBssClosedNetwork is subid 5 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.5
 * Description:
Controls whether the device will operate in closed network mode.  If
         set to true(1), then the network mode is closed and the SSID will not
         be broadcast in beacon packets.  If set to false(2), then the network
         mode is open and the SSID will be broadcast in beacon packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssClosedNetwork_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssClosedNetwork_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssClosedNetwork_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssClosedNetwork_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssClosedNetwork value.
     */

    return MFD_SUCCESS; /* wifiBssClosedNetwork value not illegal */
} /* wifiBssClosedNetwork_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssClosedNetwork_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssClosedNetwork_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssClosedNetwork undo.
     */
    /*
     * copy wifiBssClosedNetwork data
     * set rowreq_ctx->undo->wifiBssClosedNetwork from rowreq_ctx->data.wifiBssClosedNetwork
     */
    rowreq_ctx->undo->wifiBssClosedNetwork = rowreq_ctx->data.wifiBssClosedNetwork;


    return MFD_SUCCESS;
} /* wifiBssClosedNetwork_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssClosedNetwork_val
 *        A long containing the new value.
 */
int
wifiBssClosedNetwork_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssClosedNetwork_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssClosedNetwork_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssClosedNetwork value.
     * set wifiBssClosedNetwork value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssClosedNetwork = wifiBssClosedNetwork_val;

    return MFD_SUCCESS;
} /* wifiBssClosedNetwork_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssClosedNetwork_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssClosedNetwork_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssClosedNetwork undo.
     */
    /*
     * copy wifiBssClosedNetwork data
     * set rowreq_ctx->data.wifiBssClosedNetwork from rowreq_ctx->undo->wifiBssClosedNetwork
     */
    rowreq_ctx->data.wifiBssClosedNetwork = rowreq_ctx->undo->wifiBssClosedNetwork;

    
    return MFD_SUCCESS;
} /* wifiBssClosedNetwork_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssAccessMode
 * wifiBssAccessMode is subid 6 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.6
 * Description:
Controls what stations will be given access to the device.  If set to
         allowAny(1), then any station will be allowed to connect.  If set
         to restrictToList(2), then only stations whose MAC address appears in
         the wifiBssAccessTable will be allowed to connect.  If set to 
         denyList(3), any station will be allowed to connect except those in 
         the wifiBssAccessTable.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  allowAny(1), allowList(2), denyList(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssAccessMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  allowAny(1), allowList(2), denyList(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssAccessMode_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessMode_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssAccessMode value.
     */

    return MFD_SUCCESS; /* wifiBssAccessMode value not illegal */
} /* wifiBssAccessMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssAccessMode_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssAccessMode undo.
     */
    /*
     * copy wifiBssAccessMode data
     * set rowreq_ctx->undo->wifiBssAccessMode from rowreq_ctx->data.wifiBssAccessMode
     */
    rowreq_ctx->undo->wifiBssAccessMode = rowreq_ctx->data.wifiBssAccessMode;


    return MFD_SUCCESS;
} /* wifiBssAccessMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssAccessMode_val
 *        A long containing the new value.
 */
int
wifiBssAccessMode_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessMode_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssAccessMode value.
     * set wifiBssAccessMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssAccessMode = wifiBssAccessMode_val;

    return MFD_SUCCESS;
} /* wifiBssAccessMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssAccessMode_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssAccessMode undo.
     */
    /*
     * copy wifiBssAccessMode data
     * set rowreq_ctx->data.wifiBssAccessMode from rowreq_ctx->undo->wifiBssAccessMode
     */
    rowreq_ctx->data.wifiBssAccessMode = rowreq_ctx->undo->wifiBssAccessMode;

    
    return MFD_SUCCESS;
} /* wifiBssAccessMode_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssMaxAssociationsLimit
 * wifiBssMaxAssociationsLimit is subid 7 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.7
 * Description:
Configure the limit of maximum number of stations can associate with 
         the device.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 128;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssMaxAssociationsLimit_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *    The value is in (one of) the range set(s):  1 - 128
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssMaxAssociationsLimit_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssMaxAssociationsLimit_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMaxAssociationsLimit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssMaxAssociationsLimit value.
     */

    return MFD_SUCCESS; /* wifiBssMaxAssociationsLimit value not illegal */
} /* wifiBssMaxAssociationsLimit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssMaxAssociationsLimit_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMaxAssociationsLimit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssMaxAssociationsLimit undo.
     */
    /*
     * copy wifiBssMaxAssociationsLimit data
     * set rowreq_ctx->undo->wifiBssMaxAssociationsLimit from rowreq_ctx->data.wifiBssMaxAssociationsLimit
     */
    rowreq_ctx->undo->wifiBssMaxAssociationsLimit = rowreq_ctx->data.wifiBssMaxAssociationsLimit;


    return MFD_SUCCESS;
} /* wifiBssMaxAssociationsLimit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssMaxAssociationsLimit_val
 *        A u_long containing the new value.
 */
int
wifiBssMaxAssociationsLimit_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssMaxAssociationsLimit_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMaxAssociationsLimit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssMaxAssociationsLimit value.
     * set wifiBssMaxAssociationsLimit value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssMaxAssociationsLimit = wifiBssMaxAssociationsLimit_val;

    return MFD_SUCCESS;
} /* wifiBssMaxAssociationsLimit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssMaxAssociationsLimit_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMaxAssociationsLimit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssMaxAssociationsLimit undo.
     */
    /*
     * copy wifiBssMaxAssociationsLimit data
     * set rowreq_ctx->data.wifiBssMaxAssociationsLimit from rowreq_ctx->undo->wifiBssMaxAssociationsLimit
     */
    rowreq_ctx->data.wifiBssMaxAssociationsLimit = rowreq_ctx->undo->wifiBssMaxAssociationsLimit;

    
    return MFD_SUCCESS;
} /* wifiBssMaxAssociationsLimit_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssOpmodeCapRequired
 * wifiBssOpmodeCapRequired is subid 8 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.8
 * Description:
Configure operational capability requirement for a STA to associate to the BSS.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 4/8. Values:  none(0), erp(1), ht(2), vht(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssOpmodeCapRequired_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  none(0), erp(1), ht(2), vht(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssOpmodeCapRequired_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssOpmodeCapRequired_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssOpmodeCapRequired_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssOpmodeCapRequired value.
     */

    return MFD_SUCCESS; /* wifiBssOpmodeCapRequired value not illegal */
} /* wifiBssOpmodeCapRequired_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssOpmodeCapRequired_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssOpmodeCapRequired_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssOpmodeCapRequired undo.
     */
    /*
     * copy wifiBssOpmodeCapRequired data
     * set rowreq_ctx->undo->wifiBssOpmodeCapRequired from rowreq_ctx->data.wifiBssOpmodeCapRequired
     */
    rowreq_ctx->undo->wifiBssOpmodeCapRequired = rowreq_ctx->data.wifiBssOpmodeCapRequired;


    return MFD_SUCCESS;
} /* wifiBssOpmodeCapRequired_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssOpmodeCapRequired_val
 *        A long containing the new value.
 */
int
wifiBssOpmodeCapRequired_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssOpmodeCapRequired_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssOpmodeCapRequired_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssOpmodeCapRequired value.
     * set wifiBssOpmodeCapRequired value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssOpmodeCapRequired = wifiBssOpmodeCapRequired_val;

    return MFD_SUCCESS;
} /* wifiBssOpmodeCapRequired_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssOpmodeCapRequired_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssOpmodeCapRequired_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssOpmodeCapRequired undo.
     */
    /*
     * copy wifiBssOpmodeCapRequired data
     * set rowreq_ctx->data.wifiBssOpmodeCapRequired from rowreq_ctx->undo->wifiBssOpmodeCapRequired
     */
    rowreq_ctx->data.wifiBssOpmodeCapRequired = rowreq_ctx->undo->wifiBssOpmodeCapRequired;

    
    return MFD_SUCCESS;
} /* wifiBssOpmodeCapRequired_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssProtectedMgmtFrames
 * wifiBssProtectedMgmtFrames is subid 9 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.9
 * Description:
Configure Protected Management Frame (PMF) support on Primary or Guest WiFi interface.  
        PMF configuration is dependent on the security configuration. PMF is configurable only if 
        security setting for the wireless interface is WPA2 or WPA2-PSK
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  off(0), capable(1), required(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssProtectedMgmtFrames_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  off(0), capable(1), required(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssProtectedMgmtFrames_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssProtectedMgmtFrames_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssProtectedMgmtFrames_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssProtectedMgmtFrames value.
     */

    return MFD_SUCCESS; /* wifiBssProtectedMgmtFrames value not illegal */
} /* wifiBssProtectedMgmtFrames_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssProtectedMgmtFrames_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssProtectedMgmtFrames_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssProtectedMgmtFrames undo.
     */
    /*
     * copy wifiBssProtectedMgmtFrames data
     * set rowreq_ctx->undo->wifiBssProtectedMgmtFrames from rowreq_ctx->data.wifiBssProtectedMgmtFrames
     */
    rowreq_ctx->undo->wifiBssProtectedMgmtFrames = rowreq_ctx->data.wifiBssProtectedMgmtFrames;


    return MFD_SUCCESS;
} /* wifiBssProtectedMgmtFrames_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssProtectedMgmtFrames_val
 *        A long containing the new value.
 */
int
wifiBssProtectedMgmtFrames_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssProtectedMgmtFrames_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssProtectedMgmtFrames_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssProtectedMgmtFrames value.
     * set wifiBssProtectedMgmtFrames value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssProtectedMgmtFrames = wifiBssProtectedMgmtFrames_val;

    return MFD_SUCCESS;
} /* wifiBssProtectedMgmtFrames_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssProtectedMgmtFrames_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssProtectedMgmtFrames_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssProtectedMgmtFrames undo.
     */
    /*
     * copy wifiBssProtectedMgmtFrames data
     * set rowreq_ctx->data.wifiBssProtectedMgmtFrames from rowreq_ctx->undo->wifiBssProtectedMgmtFrames
     */
    rowreq_ctx->data.wifiBssProtectedMgmtFrames = rowreq_ctx->undo->wifiBssProtectedMgmtFrames;

    
    return MFD_SUCCESS;
} /* wifiBssProtectedMgmtFrames_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssPublicAccessMode
 * wifiBssPublicAccessMode is subid 10 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.10
 * Description:
Controls how an SSID is defined for the purposes of SSID Steering.  
         A value of private(1) defines this network as a private network.  
         A value of public(2) defines this network as a public network and 
         clients on private network will be steered away from this network. 
         A value of other(3) effective disables the SSID Steering feature 
         for this BSS.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  private(1), public(2), other(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssPublicAccessMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  private(1), public(2), other(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssPublicAccessMode_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssPublicAccessMode_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssPublicAccessMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssPublicAccessMode value.
     */

    return MFD_SUCCESS; /* wifiBssPublicAccessMode value not illegal */
} /* wifiBssPublicAccessMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssPublicAccessMode_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssPublicAccessMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssPublicAccessMode undo.
     */
    /*
     * copy wifiBssPublicAccessMode data
     * set rowreq_ctx->undo->wifiBssPublicAccessMode from rowreq_ctx->data.wifiBssPublicAccessMode
     */
    rowreq_ctx->undo->wifiBssPublicAccessMode = rowreq_ctx->data.wifiBssPublicAccessMode;


    return MFD_SUCCESS;
} /* wifiBssPublicAccessMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssPublicAccessMode_val
 *        A long containing the new value.
 */
int
wifiBssPublicAccessMode_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssPublicAccessMode_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssPublicAccessMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssPublicAccessMode value.
     * set wifiBssPublicAccessMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssPublicAccessMode = wifiBssPublicAccessMode_val;

    return MFD_SUCCESS;
} /* wifiBssPublicAccessMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssPublicAccessMode_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssPublicAccessMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssPublicAccessMode undo.
     */
    /*
     * copy wifiBssPublicAccessMode data
     * set rowreq_ctx->data.wifiBssPublicAccessMode from rowreq_ctx->undo->wifiBssPublicAccessMode
     */
    rowreq_ctx->data.wifiBssPublicAccessMode = rowreq_ctx->undo->wifiBssPublicAccessMode;

    
    return MFD_SUCCESS;
} /* wifiBssPublicAccessMode_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssMfbProbeResponse
 * wifiBssMfbProbeResponse is subid 11 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.11
 * Description:
Enables MAC Filter Based Probe Response for Access Control. 		 
        If set to true(1), then MBF Probe Response will be on.
        Set to false(2) turn offs the MBF Probe Response feature.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssMfbProbeResponse_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssMfbProbeResponse_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssMfbProbeResponse_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMfbProbeResponse_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssMfbProbeResponse value.
     */

    return MFD_SUCCESS; /* wifiBssMfbProbeResponse value not illegal */
} /* wifiBssMfbProbeResponse_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssMfbProbeResponse_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMfbProbeResponse_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssMfbProbeResponse undo.
     */
    /*
     * copy wifiBssMfbProbeResponse data
     * set rowreq_ctx->undo->wifiBssMfbProbeResponse from rowreq_ctx->data.wifiBssMfbProbeResponse
     */
    rowreq_ctx->undo->wifiBssMfbProbeResponse = rowreq_ctx->data.wifiBssMfbProbeResponse;


    return MFD_SUCCESS;
} /* wifiBssMfbProbeResponse_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssMfbProbeResponse_val
 *        A long containing the new value.
 */
int
wifiBssMfbProbeResponse_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssMfbProbeResponse_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMfbProbeResponse_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssMfbProbeResponse value.
     * set wifiBssMfbProbeResponse value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssMfbProbeResponse = wifiBssMfbProbeResponse_val;

    return MFD_SUCCESS;
} /* wifiBssMfbProbeResponse_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssMfbProbeResponse_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssMfbProbeResponse_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssMfbProbeResponse undo.
     */
    /*
     * copy wifiBssMfbProbeResponse data
     * set rowreq_ctx->data.wifiBssMfbProbeResponse from rowreq_ctx->undo->wifiBssMfbProbeResponse
     */
    rowreq_ctx->data.wifiBssMfbProbeResponse = rowreq_ctx->undo->wifiBssMfbProbeResponse;

    
    return MFD_SUCCESS;
} /* wifiBssMfbProbeResponse_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssAccessTableClear
 * wifiBssAccessTableClear is subid 12 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.12
 * Description:
Clears the for Access Table for this SSID. 		 
        If set to true(1), then the Access Table will be cleared.
        Set to false(2) then the Access Table remains unchanged.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssAccessTableClear_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssAccessTableClear_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessTableClear_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessTableClear_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssAccessTableClear value.
     */

    return MFD_SUCCESS; /* wifiBssAccessTableClear value not illegal */
} /* wifiBssAccessTableClear_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssAccessTableClear_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessTableClear_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssAccessTableClear undo.
     */
    /*
     * copy wifiBssAccessTableClear data
     * set rowreq_ctx->undo->wifiBssAccessTableClear from rowreq_ctx->data.wifiBssAccessTableClear
     */
    rowreq_ctx->undo->wifiBssAccessTableClear = rowreq_ctx->data.wifiBssAccessTableClear;


    return MFD_SUCCESS;
} /* wifiBssAccessTableClear_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssAccessTableClear_val
 *        A long containing the new value.
 */
int
wifiBssAccessTableClear_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessTableClear_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessTableClear_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssAccessTableClear value.
     * set wifiBssAccessTableClear value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssAccessTableClear = wifiBssAccessTableClear_val;

    return MFD_SUCCESS;
} /* wifiBssAccessTableClear_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssAccessTableClear_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssAccessTableClear_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssAccessTableClear undo.
     */
    /*
     * copy wifiBssAccessTableClear data
     * set rowreq_ctx->data.wifiBssAccessTableClear from rowreq_ctx->undo->wifiBssAccessTableClear
     */
    rowreq_ctx->data.wifiBssAccessTableClear = rowreq_ctx->undo->wifiBssAccessTableClear;

    
    return MFD_SUCCESS;
} /* wifiBssAccessTableClear_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssIASSchedulerEnable
 * wifiBssIASSchedulerEnable is subid 13 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.13
 * Description:
Controls the IAS scheduler traffic rule.
        If set to true(1), then the IAS traffic rule for this BSS is enabled.
	Set to false(2) then the IAS traffic rule for this BSS uses the default scheduler.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssIASSchedulerEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssIASSchedulerEnable_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssIASSchedulerEnable_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssIASSchedulerEnable value.
     */

    return MFD_SUCCESS; /* wifiBssIASSchedulerEnable value not illegal */
} /* wifiBssIASSchedulerEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssIASSchedulerEnable_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssIASSchedulerEnable undo.
     */
    /*
     * copy wifiBssIASSchedulerEnable data
     * set rowreq_ctx->undo->wifiBssIASSchedulerEnable from rowreq_ctx->data.wifiBssIASSchedulerEnable
     */
    rowreq_ctx->undo->wifiBssIASSchedulerEnable = rowreq_ctx->data.wifiBssIASSchedulerEnable;


    return MFD_SUCCESS;
} /* wifiBssIASSchedulerEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssIASSchedulerEnable_val
 *        A long containing the new value.
 */
int
wifiBssIASSchedulerEnable_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssIASSchedulerEnable_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssIASSchedulerEnable value.
     * set wifiBssIASSchedulerEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssIASSchedulerEnable = wifiBssIASSchedulerEnable_val;

    return MFD_SUCCESS;
} /* wifiBssIASSchedulerEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssIASSchedulerEnable_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssIASSchedulerEnable undo.
     */
    /*
     * copy wifiBssIASSchedulerEnable data
     * set rowreq_ctx->data.wifiBssIASSchedulerEnable from rowreq_ctx->undo->wifiBssIASSchedulerEnable
     */
    rowreq_ctx->data.wifiBssIASSchedulerEnable = rowreq_ctx->undo->wifiBssIASSchedulerEnable;

    
    return MFD_SUCCESS;
} /* wifiBssIASSchedulerEnable_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssEntry.wifiBssIASSchedulerType
 * wifiBssIASSchedulerType is subid 14 of wifiBssEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.1.1.14
 * Description:
Enables IAS per-BSS traffic control by specifying the scheduler type.		 
        Default value is data - (1).
	Set to (1) for data, (2) for public, (3) for video.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: data
 *
 * Enum range: 3/8. Values:  data(1), public(2), video(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssIASSchedulerType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  data(1), public(2), video(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssIASSchedulerType_check_value( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssIASSchedulerType_val)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerType_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssIASSchedulerType value.
     */

    return MFD_SUCCESS; /* wifiBssIASSchedulerType value not illegal */
} /* wifiBssIASSchedulerType_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssIASSchedulerType_undo_setup( wifiBssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerType_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssIASSchedulerType undo.
     */
    /*
     * copy wifiBssIASSchedulerType data
     * set rowreq_ctx->undo->wifiBssIASSchedulerType from rowreq_ctx->data.wifiBssIASSchedulerType
     */
    rowreq_ctx->undo->wifiBssIASSchedulerType = rowreq_ctx->data.wifiBssIASSchedulerType;


    return MFD_SUCCESS;
} /* wifiBssIASSchedulerType_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssIASSchedulerType_val
 *        A long containing the new value.
 */
int
wifiBssIASSchedulerType_set( wifiBssTable_rowreq_ctx *rowreq_ctx, u_long wifiBssIASSchedulerType_val )
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerType_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssIASSchedulerType value.
     * set wifiBssIASSchedulerType value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssIASSchedulerType = wifiBssIASSchedulerType_val;

    return MFD_SUCCESS;
} /* wifiBssIASSchedulerType_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssIASSchedulerType_undo( wifiBssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssTable:wifiBssIASSchedulerType_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssIASSchedulerType undo.
     */
    /*
     * copy wifiBssIASSchedulerType data
     * set rowreq_ctx->data.wifiBssIASSchedulerType from rowreq_ctx->undo->wifiBssIASSchedulerType
     */
    rowreq_ctx->data.wifiBssIASSchedulerType = rowreq_ctx->undo->wifiBssIASSchedulerType;

    
    return MFD_SUCCESS;
} /* wifiBssIASSchedulerType_undo */

/** @} */
