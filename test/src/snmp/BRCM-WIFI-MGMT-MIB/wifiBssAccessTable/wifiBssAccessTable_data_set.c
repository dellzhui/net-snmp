/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "wifiBssAccessTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wifiBssAccessTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRCM-WIFI-MGMT-MIB::wifiBssAccessTable is subid 1 of wifiMbssAccess.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.4.1, length: 16
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * wifiBssAccessTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * wifiBssAccessTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssAccessTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiBssAccessTable_undo_setup( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup wifiBssAccessTable undo.
     * set up wifiBssAccessTable undo information, in preparation for a set.
     * Undo storage is in (* wifiBssAccessStatus_val_ptr )*
     */

    return rc;
} /* wifiBssAccessTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssAccessTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiBssAccessTable_undo( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> wifiBssAccessTable undo.
     * wifiBssAccessTable undo information, in response to a failed set.
     * Undo storage is in (* wifiBssAccessStatus_val_ptr )*
     */

    return rc;
} /* wifiBssAccessTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssAccessTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssAccessTable_undo_cleanup( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup wifiBssAccessTable undo.
     * Undo storage is in (* wifiBssAccessStatus_val_ptr )*
     */

    return rc;
} /* wifiBssAccessTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiBssAccessTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiBssAccessTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssAccessTable_commit( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit wifiBssAccessTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WIFIBSSACCESSSTATION_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSACCESSSTATION_FLAG; /* clear wifiBssAccessStation */
       /*
        * TODO:482:o: |-> commit column wifiBssAccessStation.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssAccessTable column wifiBssAccessStation commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssAccessStation
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSACCESSSTATION_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIBSSACCESSSTATUS_FLAG) {
       save_flags &= ~COLUMN_WIFIBSSACCESSSTATUS_FLAG; /* clear wifiBssAccessStatus */
       /*
        * TODO:482:o: |-> commit column wifiBssAccessStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiBssAccessTable column wifiBssAccessStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiBssAccessStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIBSSACCESSSTATUS_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* wifiBssAccessTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiBssAccessTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiBssAccessTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiBssAccessTable_undo_commit( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo wifiBssAccessTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* wifiBssAccessTable_undo_commit */

/*
 * TODO:440:M: Implement wifiBssAccessTable node value checks.
 * TODO:450:M: Implement wifiBssAccessTable undo functions.
 * TODO:460:M: Implement wifiBssAccessTable set functions.
 * TODO:480:M: Implement wifiBssAccessTable commit functions.
 */
/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssAccessEntry.wifiBssAccessStation
 * wifiBssAccessStation is subid 2 of wifiBssAccessEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.4.1.1.2
 * Description:
A MAC address of a station which will be allowed to connect to the 
         service set if wifiBssAccessMode is set to restrictToList(2), or
         forbidden if wifiBssAccessMode is set to denyList(3).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssAccessStation_val_ptr
 *        A char containing the new value.
 * @param wifiBssAccessStation_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiBssAccessStation_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssAccessTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.wifiBssAccessStation).
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssAccessStation_check_value( wifiBssAccessTable_rowreq_ctx *rowreq_ctx, char *wifiBssAccessStation_val_ptr,  size_t wifiBssAccessStation_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStation_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiBssAccessStation_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wifiBssAccessStation value.
     */

    return MFD_SUCCESS; /* wifiBssAccessStation value not illegal */
} /* wifiBssAccessStation_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssAccessTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssAccessTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssAccessStation_undo_setup( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStation_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssAccessStation undo.
     */
    /*
     * copy wifiBssAccessStation and wifiBssAccessStation_len data
     * set rowreq_ctx->undo->wifiBssAccessStation from rowreq_ctx->data.wifiBssAccessStation
     */
    memcpy( rowreq_ctx->undo->wifiBssAccessStation, rowreq_ctx->data.wifiBssAccessStation,
            (rowreq_ctx->data.wifiBssAccessStation_len * sizeof(rowreq_ctx->undo->wifiBssAccessStation[0])));
    rowreq_ctx->undo->wifiBssAccessStation_len = rowreq_ctx->data.wifiBssAccessStation_len;


    return MFD_SUCCESS;
} /* wifiBssAccessStation_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssAccessStation_val_ptr
 *        A char containing the new value.
 * @param wifiBssAccessStation_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiBssAccessStation_val_ptr
 */
int
wifiBssAccessStation_set( wifiBssAccessTable_rowreq_ctx *rowreq_ctx, char *wifiBssAccessStation_val_ptr,  size_t wifiBssAccessStation_val_ptr_len )
{

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStation_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiBssAccessStation_val_ptr);

    /*
     * TODO:461:M: |-> Set wifiBssAccessStation value.
     * set wifiBssAccessStation value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.wifiBssAccessStation, wifiBssAccessStation_val_ptr, wifiBssAccessStation_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.wifiBssAccessStation_len = wifiBssAccessStation_val_ptr_len / sizeof(wifiBssAccessStation_val_ptr[0]);

    return MFD_SUCCESS;
} /* wifiBssAccessStation_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssAccessStation_undo( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStation_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssAccessStation undo.
     */
    /*
     * copy wifiBssAccessStation and wifiBssAccessStation_len data
     * set rowreq_ctx->data.wifiBssAccessStation from rowreq_ctx->undo->wifiBssAccessStation
     */
    memcpy( rowreq_ctx->data.wifiBssAccessStation, rowreq_ctx->undo->wifiBssAccessStation,
            (rowreq_ctx->undo->wifiBssAccessStation_len * sizeof(rowreq_ctx->data.wifiBssAccessStation[0])));
    rowreq_ctx->data.wifiBssAccessStation_len = rowreq_ctx->undo->wifiBssAccessStation_len;

    
    return MFD_SUCCESS;
} /* wifiBssAccessStation_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiBssAccessEntry.wifiBssAccessStatus
 * wifiBssAccessStatus is subid 3 of wifiBssAccessEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.2.4.1.1.3
 * Description:
The status of this conceptual row.

         To create a row in this table, a manager must set this object to 
         either createAndGo(4) or createAndWait(5).

         Until instances of all corresponding columns are appropriately 
         configured, the value of the corresponding instance of the 
         wifiBssAccessStatus column is 'notReady'.

         In particular, a newly created row cannot be made active until the 
         corresponding instance of wifiBssAccessStation has been set.
         
         Only rows with a status of active(1) will be applied.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiBssAccessStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiBssAccessTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiBssAccessStatus_check_value( wifiBssAccessTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessStatus_val)
{
    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiBssAccessStatus value.
     */

    return MFD_SUCCESS; /* wifiBssAccessStatus value not illegal */
} /* wifiBssAccessStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiBssAccessTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiBssAccessTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiBssAccessStatus_undo_setup( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiBssAccessStatus undo.
     */
    /*
     * copy wifiBssAccessStatus data
     * set rowreq_ctx->undo->wifiBssAccessStatus from rowreq_ctx->data.wifiBssAccessStatus
     */
    rowreq_ctx->undo->wifiBssAccessStatus = rowreq_ctx->data.wifiBssAccessStatus;


    return MFD_SUCCESS;
} /* wifiBssAccessStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiBssAccessStatus_val
 *        A long containing the new value.
 */
int
wifiBssAccessStatus_set( wifiBssAccessTable_rowreq_ctx *rowreq_ctx, u_long wifiBssAccessStatus_val )
{

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiBssAccessStatus value.
     * set wifiBssAccessStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiBssAccessStatus = wifiBssAccessStatus_val;

    return MFD_SUCCESS;
} /* wifiBssAccessStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiBssAccessStatus_undo( wifiBssAccessTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiBssAccessTable:wifiBssAccessStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiBssAccessStatus undo.
     */
    /*
     * copy wifiBssAccessStatus data
     * set rowreq_ctx->data.wifiBssAccessStatus from rowreq_ctx->undo->wifiBssAccessStatus
     */
    rowreq_ctx->data.wifiBssAccessStatus = rowreq_ctx->undo->wifiBssAccessStatus;

    
    return MFD_SUCCESS;
} /* wifiBssAccessStatus_undo */

/** @} */
