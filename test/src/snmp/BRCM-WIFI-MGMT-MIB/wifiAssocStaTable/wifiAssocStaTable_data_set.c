/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "wifiAssocStaTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wifiAssocStaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaTable is subid 3 of wifiAssocStaDiagnostics.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3, length: 15
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * wifiAssocStaTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * wifiAssocStaTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiAssocStaTable_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup wifiAssocStaTable undo.
     * set up wifiAssocStaTable undo information, in preparation for a set.
     * Undo storage is in (* wifiAssocStaRxRateLimit_val_ptr )*
     */

    return rc;
} /* wifiAssocStaTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wifiAssocStaTable_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> wifiAssocStaTable undo.
     * wifiAssocStaTable undo information, in response to a failed set.
     * Undo storage is in (* wifiAssocStaRxRateLimit_val_ptr )*
     */

    return rc;
} /* wifiAssocStaTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiAssocStaTable_undo_cleanup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup wifiAssocStaTable undo.
     * Undo storage is in (* wifiAssocStaRxRateLimit_val_ptr )*
     */

    return rc;
} /* wifiAssocStaTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiAssocStaTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiAssocStaTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiAssocStaTable_commit( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit wifiAssocStaTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WIFIASSOCSTARSSI_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTARSSI_FLAG; /* clear wifiAssocStaRssi */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaRssi.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaRssi commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaRssi
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTARSSI_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPHYRATE_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPHYRATE_FLAG; /* clear wifiAssocStaPhyRate */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPhyRate.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPhyRate commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPhyRate
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPHYRATE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAMACADDRESS_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAMACADDRESS_FLAG; /* clear wifiAssocStaMacAddress */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaMacAddress.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaMacAddress commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaMacAddress
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAMACADDRESS_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPREQUESTED_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPREQUESTED_FLAG; /* clear wifiAssocStaPRequested */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPRequested.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPRequested commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPRequested
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPREQUESTED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPSTORED_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPSTORED_FLAG; /* clear wifiAssocStaPStored */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPStored.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPStored commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPStored
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPSTORED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPDROPPED_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPDROPPED_FLAG; /* clear wifiAssocStaPDropped */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPDropped.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPDropped commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPDropped
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPDROPPED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPRETRIED_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPRETRIED_FLAG; /* clear wifiAssocStaPRetried */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPRetried.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPRetried commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPRetried
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPRETRIED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPUTILIZATION_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPUTILIZATION_FLAG; /* clear wifiAssocStaPUtilization */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPUtilization.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPUtilization commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPUtilization
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPUTILIZATION_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPQLENGTH_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPQLENGTH_FLAG; /* clear wifiAssocStaPQLength */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPQLength.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPQLength commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPQLength
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPQLENGTH_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPRTSFAIL_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPRTSFAIL_FLAG; /* clear wifiAssocStaPRtsFail */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPRtsFail.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPRtsFail commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPRtsFail
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPRTSFAIL_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPRTRYDROP_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPRTRYDROP_FLAG; /* clear wifiAssocStaPRtryDrop */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPRtryDrop.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPRtryDrop commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPRtryDrop
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPRTRYDROP_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPPSRETRY_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPPSRETRY_FLAG; /* clear wifiAssocStaPPSRetry */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPPSRetry.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPPSRetry commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPPSRetry
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPPSRETRY_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPACKED_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPACKED_FLAG; /* clear wifiAssocStaPAcked */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPAcked.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPAcked commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPAcked
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPACKED_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPTPUT_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPTPUT_FLAG; /* clear wifiAssocStaPTput */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPTput.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPTput commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPTput
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPTPUT_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTAPPHYRATE_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTAPPHYRATE_FLAG; /* clear wifiAssocStaPPhyRate */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaPPhyRate.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaPPhyRate commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaPPhyRate
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTAPPHYRATE_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTATXBYTES_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTATXBYTES_FLAG; /* clear wifiAssocStaTxBytes */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaTxBytes.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaTxBytes commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaTxBytes
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTATXBYTES_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTARXBYTES_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTARXBYTES_FLAG; /* clear wifiAssocStaRxBytes */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaRxBytes.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaRxBytes commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaRxBytes
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTARXBYTES_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTATXRATELIMIT_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTATXRATELIMIT_FLAG; /* clear wifiAssocStaTxRateLimit */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaTxRateLimit.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaTxRateLimit commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaTxRateLimit
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTATXRATELIMIT_FLAG;
       }
    }

    if (save_flags & COLUMN_WIFIASSOCSTARXRATELIMIT_FLAG) {
       save_flags &= ~COLUMN_WIFIASSOCSTARXRATELIMIT_FLAG; /* clear wifiAssocStaRxRateLimit */
       /*
        * TODO:482:o: |-> commit column wifiAssocStaRxRateLimit.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"wifiAssocStaTable column wifiAssocStaRxRateLimit commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wifiAssocStaRxRateLimit
             */
            rowreq_ctx->column_set_flags |= COLUMN_WIFIASSOCSTARXRATELIMIT_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* wifiAssocStaTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wifiAssocStaTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wifiAssocStaTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wifiAssocStaTable_undo_commit( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo wifiAssocStaTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* wifiAssocStaTable_undo_commit */

/*
 * TODO:440:M: Implement wifiAssocStaTable node value checks.
 * TODO:450:M: Implement wifiAssocStaTable undo functions.
 * TODO:460:M: Implement wifiAssocStaTable set functions.
 * TODO:480:M: Implement wifiAssocStaTable commit functions.
 */
/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaRssi
 * wifiAssocStaRssi is subid 1 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.1
 * Description:
RSSI(Signal Strength) of the STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaRssi_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaRssi_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, long wifiAssocStaRssi_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRssi_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaRssi value.
     */

    return MFD_SUCCESS; /* wifiAssocStaRssi value not illegal */
} /* wifiAssocStaRssi_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaRssi_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRssi_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaRssi undo.
     */
    /*
     * copy wifiAssocStaRssi data
     * set rowreq_ctx->undo->wifiAssocStaRssi from rowreq_ctx->data.wifiAssocStaRssi
     */
    rowreq_ctx->undo->wifiAssocStaRssi = rowreq_ctx->data.wifiAssocStaRssi;


    return MFD_SUCCESS;
} /* wifiAssocStaRssi_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaRssi_val
 *        A long containing the new value.
 */
int
wifiAssocStaRssi_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, long wifiAssocStaRssi_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRssi_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaRssi value.
     * set wifiAssocStaRssi value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaRssi = wifiAssocStaRssi_val;

    return MFD_SUCCESS;
} /* wifiAssocStaRssi_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaRssi_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRssi_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaRssi undo.
     */
    /*
     * copy wifiAssocStaRssi data
     * set rowreq_ctx->data.wifiAssocStaRssi from rowreq_ctx->undo->wifiAssocStaRssi
     */
    rowreq_ctx->data.wifiAssocStaRssi = rowreq_ctx->undo->wifiAssocStaRssi;

    
    return MFD_SUCCESS;
} /* wifiAssocStaRssi_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPhyRate
 * wifiAssocStaPhyRate is subid 2 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.2
 * Description:
Physical rate of the STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPhyRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPhyRate_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, long wifiAssocStaPhyRate_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPhyRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPhyRate value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPhyRate value not illegal */
} /* wifiAssocStaPhyRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPhyRate_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPhyRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPhyRate undo.
     */
    /*
     * copy wifiAssocStaPhyRate data
     * set rowreq_ctx->undo->wifiAssocStaPhyRate from rowreq_ctx->data.wifiAssocStaPhyRate
     */
    rowreq_ctx->undo->wifiAssocStaPhyRate = rowreq_ctx->data.wifiAssocStaPhyRate;


    return MFD_SUCCESS;
} /* wifiAssocStaPhyRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPhyRate_val
 *        A long containing the new value.
 */
int
wifiAssocStaPhyRate_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, long wifiAssocStaPhyRate_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPhyRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPhyRate value.
     * set wifiAssocStaPhyRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPhyRate = wifiAssocStaPhyRate_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPhyRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPhyRate_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPhyRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPhyRate undo.
     */
    /*
     * copy wifiAssocStaPhyRate data
     * set rowreq_ctx->data.wifiAssocStaPhyRate from rowreq_ctx->undo->wifiAssocStaPhyRate
     */
    rowreq_ctx->data.wifiAssocStaPhyRate = rowreq_ctx->undo->wifiAssocStaPhyRate;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPhyRate_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaMacAddress
 * wifiAssocStaMacAddress is subid 4 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.4
 * Description:
MAC address of the STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaMacAddress_val_ptr
 *        A char containing the new value.
 * @param wifiAssocStaMacAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiAssocStaMacAddress_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.wifiAssocStaMacAddress).
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaMacAddress_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, char *wifiAssocStaMacAddress_val_ptr,  size_t wifiAssocStaMacAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaMacAddress_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiAssocStaMacAddress_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaMacAddress value.
     */

    return MFD_SUCCESS; /* wifiAssocStaMacAddress value not illegal */
} /* wifiAssocStaMacAddress_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaMacAddress_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaMacAddress_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaMacAddress undo.
     */
    /*
     * copy wifiAssocStaMacAddress and wifiAssocStaMacAddress_len data
     * set rowreq_ctx->undo->wifiAssocStaMacAddress from rowreq_ctx->data.wifiAssocStaMacAddress
     */
    memcpy( rowreq_ctx->undo->wifiAssocStaMacAddress, rowreq_ctx->data.wifiAssocStaMacAddress,
            (rowreq_ctx->data.wifiAssocStaMacAddress_len * sizeof(rowreq_ctx->undo->wifiAssocStaMacAddress[0])));
    rowreq_ctx->undo->wifiAssocStaMacAddress_len = rowreq_ctx->data.wifiAssocStaMacAddress_len;


    return MFD_SUCCESS;
} /* wifiAssocStaMacAddress_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaMacAddress_val_ptr
 *        A char containing the new value.
 * @param wifiAssocStaMacAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by wifiAssocStaMacAddress_val_ptr
 */
int
wifiAssocStaMacAddress_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, char *wifiAssocStaMacAddress_val_ptr,  size_t wifiAssocStaMacAddress_val_ptr_len )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaMacAddress_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wifiAssocStaMacAddress_val_ptr);

    /*
     * TODO:461:M: |-> Set wifiAssocStaMacAddress value.
     * set wifiAssocStaMacAddress value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.wifiAssocStaMacAddress, wifiAssocStaMacAddress_val_ptr, wifiAssocStaMacAddress_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.wifiAssocStaMacAddress_len = wifiAssocStaMacAddress_val_ptr_len / sizeof(wifiAssocStaMacAddress_val_ptr[0]);

    return MFD_SUCCESS;
} /* wifiAssocStaMacAddress_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaMacAddress_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaMacAddress_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaMacAddress undo.
     */
    /*
     * copy wifiAssocStaMacAddress and wifiAssocStaMacAddress_len data
     * set rowreq_ctx->data.wifiAssocStaMacAddress from rowreq_ctx->undo->wifiAssocStaMacAddress
     */
    memcpy( rowreq_ctx->data.wifiAssocStaMacAddress, rowreq_ctx->undo->wifiAssocStaMacAddress,
            (rowreq_ctx->undo->wifiAssocStaMacAddress_len * sizeof(rowreq_ctx->data.wifiAssocStaMacAddress[0])));
    rowreq_ctx->data.wifiAssocStaMacAddress_len = rowreq_ctx->undo->wifiAssocStaMacAddress_len;

    
    return MFD_SUCCESS;
} /* wifiAssocStaMacAddress_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPRequested
 * wifiAssocStaPRequested is subid 5 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.5
 * Description:
Total number of packets requested.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPRequested_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPRequested_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRequested_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRequested_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPRequested value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPRequested value not illegal */
} /* wifiAssocStaPRequested_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPRequested_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRequested_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPRequested undo.
     */
    /*
     * copy wifiAssocStaPRequested data
     * set rowreq_ctx->undo->wifiAssocStaPRequested from rowreq_ctx->data.wifiAssocStaPRequested
     */
    rowreq_ctx->undo->wifiAssocStaPRequested = rowreq_ctx->data.wifiAssocStaPRequested;


    return MFD_SUCCESS;
} /* wifiAssocStaPRequested_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPRequested_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPRequested_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRequested_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRequested_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPRequested value.
     * set wifiAssocStaPRequested value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPRequested = wifiAssocStaPRequested_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPRequested_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPRequested_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRequested_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPRequested undo.
     */
    /*
     * copy wifiAssocStaPRequested data
     * set rowreq_ctx->data.wifiAssocStaPRequested from rowreq_ctx->undo->wifiAssocStaPRequested
     */
    rowreq_ctx->data.wifiAssocStaPRequested = rowreq_ctx->undo->wifiAssocStaPRequested;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPRequested_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPStored
 * wifiAssocStaPStored is subid 6 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.6
 * Description:
Total number of packets stored.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPStored_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPStored_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPStored_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPStored_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPStored value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPStored value not illegal */
} /* wifiAssocStaPStored_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPStored_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPStored_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPStored undo.
     */
    /*
     * copy wifiAssocStaPStored data
     * set rowreq_ctx->undo->wifiAssocStaPStored from rowreq_ctx->data.wifiAssocStaPStored
     */
    rowreq_ctx->undo->wifiAssocStaPStored = rowreq_ctx->data.wifiAssocStaPStored;


    return MFD_SUCCESS;
} /* wifiAssocStaPStored_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPStored_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPStored_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPStored_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPStored_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPStored value.
     * set wifiAssocStaPStored value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPStored = wifiAssocStaPStored_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPStored_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPStored_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPStored_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPStored undo.
     */
    /*
     * copy wifiAssocStaPStored data
     * set rowreq_ctx->data.wifiAssocStaPStored from rowreq_ctx->undo->wifiAssocStaPStored
     */
    rowreq_ctx->data.wifiAssocStaPStored = rowreq_ctx->undo->wifiAssocStaPStored;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPStored_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPDropped
 * wifiAssocStaPDropped is subid 7 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.7
 * Description:
Total number of packets dropped.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPDropped_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPDropped_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPDropped_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPDropped_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPDropped value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPDropped value not illegal */
} /* wifiAssocStaPDropped_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPDropped_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPDropped_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPDropped undo.
     */
    /*
     * copy wifiAssocStaPDropped data
     * set rowreq_ctx->undo->wifiAssocStaPDropped from rowreq_ctx->data.wifiAssocStaPDropped
     */
    rowreq_ctx->undo->wifiAssocStaPDropped = rowreq_ctx->data.wifiAssocStaPDropped;


    return MFD_SUCCESS;
} /* wifiAssocStaPDropped_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPDropped_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPDropped_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPDropped_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPDropped_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPDropped value.
     * set wifiAssocStaPDropped value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPDropped = wifiAssocStaPDropped_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPDropped_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPDropped_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPDropped_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPDropped undo.
     */
    /*
     * copy wifiAssocStaPDropped data
     * set rowreq_ctx->data.wifiAssocStaPDropped from rowreq_ctx->undo->wifiAssocStaPDropped
     */
    rowreq_ctx->data.wifiAssocStaPDropped = rowreq_ctx->undo->wifiAssocStaPDropped;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPDropped_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPRetried
 * wifiAssocStaPRetried is subid 8 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.8
 * Description:
Total number of packets retried.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPRetried_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPRetried_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRetried_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRetried_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPRetried value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPRetried value not illegal */
} /* wifiAssocStaPRetried_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPRetried_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRetried_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPRetried undo.
     */
    /*
     * copy wifiAssocStaPRetried data
     * set rowreq_ctx->undo->wifiAssocStaPRetried from rowreq_ctx->data.wifiAssocStaPRetried
     */
    rowreq_ctx->undo->wifiAssocStaPRetried = rowreq_ctx->data.wifiAssocStaPRetried;


    return MFD_SUCCESS;
} /* wifiAssocStaPRetried_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPRetried_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPRetried_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRetried_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRetried_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPRetried value.
     * set wifiAssocStaPRetried value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPRetried = wifiAssocStaPRetried_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPRetried_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPRetried_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRetried_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPRetried undo.
     */
    /*
     * copy wifiAssocStaPRetried data
     * set rowreq_ctx->data.wifiAssocStaPRetried from rowreq_ctx->undo->wifiAssocStaPRetried
     */
    rowreq_ctx->data.wifiAssocStaPRetried = rowreq_ctx->undo->wifiAssocStaPRetried;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPRetried_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPUtilization
 * wifiAssocStaPUtilization is subid 9 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.9
 * Description:
Total number of packets utilized.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPUtilization_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPUtilization_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPUtilization_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPUtilization_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPUtilization value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPUtilization value not illegal */
} /* wifiAssocStaPUtilization_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPUtilization_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPUtilization_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPUtilization undo.
     */
    /*
     * copy wifiAssocStaPUtilization data
     * set rowreq_ctx->undo->wifiAssocStaPUtilization from rowreq_ctx->data.wifiAssocStaPUtilization
     */
    rowreq_ctx->undo->wifiAssocStaPUtilization = rowreq_ctx->data.wifiAssocStaPUtilization;


    return MFD_SUCCESS;
} /* wifiAssocStaPUtilization_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPUtilization_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPUtilization_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPUtilization_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPUtilization_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPUtilization value.
     * set wifiAssocStaPUtilization value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPUtilization = wifiAssocStaPUtilization_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPUtilization_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPUtilization_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPUtilization_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPUtilization undo.
     */
    /*
     * copy wifiAssocStaPUtilization data
     * set rowreq_ctx->data.wifiAssocStaPUtilization from rowreq_ctx->undo->wifiAssocStaPUtilization
     */
    rowreq_ctx->data.wifiAssocStaPUtilization = rowreq_ctx->undo->wifiAssocStaPUtilization;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPUtilization_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPQLength
 * wifiAssocStaPQLength is subid 10 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.10
 * Description:
The maximum capacity of the WL driver Tx Queue.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPQLength_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPQLength_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPQLength_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPQLength_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPQLength value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPQLength value not illegal */
} /* wifiAssocStaPQLength_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPQLength_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPQLength_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPQLength undo.
     */
    /*
     * copy wifiAssocStaPQLength data
     * set rowreq_ctx->undo->wifiAssocStaPQLength from rowreq_ctx->data.wifiAssocStaPQLength
     */
    rowreq_ctx->undo->wifiAssocStaPQLength = rowreq_ctx->data.wifiAssocStaPQLength;


    return MFD_SUCCESS;
} /* wifiAssocStaPQLength_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPQLength_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPQLength_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPQLength_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPQLength_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPQLength value.
     * set wifiAssocStaPQLength value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPQLength = wifiAssocStaPQLength_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPQLength_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPQLength_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPQLength_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPQLength undo.
     */
    /*
     * copy wifiAssocStaPQLength data
     * set rowreq_ctx->data.wifiAssocStaPQLength from rowreq_ctx->undo->wifiAssocStaPQLength
     */
    rowreq_ctx->data.wifiAssocStaPQLength = rowreq_ctx->undo->wifiAssocStaPQLength;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPQLength_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPRtsFail
 * wifiAssocStaPRtsFail is subid 11 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.11
 * Description:
Total number of RTS failed packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPRtsFail_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPRtsFail_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRtsFail_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtsFail_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPRtsFail value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPRtsFail value not illegal */
} /* wifiAssocStaPRtsFail_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPRtsFail_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtsFail_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPRtsFail undo.
     */
    /*
     * copy wifiAssocStaPRtsFail data
     * set rowreq_ctx->undo->wifiAssocStaPRtsFail from rowreq_ctx->data.wifiAssocStaPRtsFail
     */
    rowreq_ctx->undo->wifiAssocStaPRtsFail = rowreq_ctx->data.wifiAssocStaPRtsFail;


    return MFD_SUCCESS;
} /* wifiAssocStaPRtsFail_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPRtsFail_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPRtsFail_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRtsFail_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtsFail_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPRtsFail value.
     * set wifiAssocStaPRtsFail value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPRtsFail = wifiAssocStaPRtsFail_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPRtsFail_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPRtsFail_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtsFail_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPRtsFail undo.
     */
    /*
     * copy wifiAssocStaPRtsFail data
     * set rowreq_ctx->data.wifiAssocStaPRtsFail from rowreq_ctx->undo->wifiAssocStaPRtsFail
     */
    rowreq_ctx->data.wifiAssocStaPRtsFail = rowreq_ctx->undo->wifiAssocStaPRtsFail;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPRtsFail_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPRtryDrop
 * wifiAssocStaPRtryDrop is subid 12 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.12
 * Description:
Total number of retry dropped packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPRtryDrop_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPRtryDrop_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRtryDrop_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtryDrop_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPRtryDrop value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPRtryDrop value not illegal */
} /* wifiAssocStaPRtryDrop_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPRtryDrop_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtryDrop_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPRtryDrop undo.
     */
    /*
     * copy wifiAssocStaPRtryDrop data
     * set rowreq_ctx->undo->wifiAssocStaPRtryDrop from rowreq_ctx->data.wifiAssocStaPRtryDrop
     */
    rowreq_ctx->undo->wifiAssocStaPRtryDrop = rowreq_ctx->data.wifiAssocStaPRtryDrop;


    return MFD_SUCCESS;
} /* wifiAssocStaPRtryDrop_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPRtryDrop_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPRtryDrop_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPRtryDrop_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtryDrop_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPRtryDrop value.
     * set wifiAssocStaPRtryDrop value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPRtryDrop = wifiAssocStaPRtryDrop_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPRtryDrop_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPRtryDrop_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPRtryDrop_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPRtryDrop undo.
     */
    /*
     * copy wifiAssocStaPRtryDrop data
     * set rowreq_ctx->data.wifiAssocStaPRtryDrop from rowreq_ctx->undo->wifiAssocStaPRtryDrop
     */
    rowreq_ctx->data.wifiAssocStaPRtryDrop = rowreq_ctx->undo->wifiAssocStaPRtryDrop;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPRtryDrop_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPPSRetry
 * wifiAssocStaPPSRetry is subid 13 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.13
 * Description:
Total number of power save retry packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPPSRetry_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPPSRetry_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPPSRetry_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPSRetry_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPPSRetry value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPPSRetry value not illegal */
} /* wifiAssocStaPPSRetry_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPPSRetry_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPSRetry_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPPSRetry undo.
     */
    /*
     * copy wifiAssocStaPPSRetry data
     * set rowreq_ctx->undo->wifiAssocStaPPSRetry from rowreq_ctx->data.wifiAssocStaPPSRetry
     */
    rowreq_ctx->undo->wifiAssocStaPPSRetry = rowreq_ctx->data.wifiAssocStaPPSRetry;


    return MFD_SUCCESS;
} /* wifiAssocStaPPSRetry_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPPSRetry_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPPSRetry_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPPSRetry_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPSRetry_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPPSRetry value.
     * set wifiAssocStaPPSRetry value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPPSRetry = wifiAssocStaPPSRetry_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPPSRetry_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPPSRetry_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPSRetry_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPPSRetry undo.
     */
    /*
     * copy wifiAssocStaPPSRetry data
     * set rowreq_ctx->data.wifiAssocStaPPSRetry from rowreq_ctx->undo->wifiAssocStaPPSRetry
     */
    rowreq_ctx->data.wifiAssocStaPPSRetry = rowreq_ctx->undo->wifiAssocStaPPSRetry;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPPSRetry_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPAcked
 * wifiAssocStaPAcked is subid 14 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.14
 * Description:
Total number of acked packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPAcked_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPAcked_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPAcked_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPAcked_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPAcked value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPAcked value not illegal */
} /* wifiAssocStaPAcked_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPAcked_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPAcked_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPAcked undo.
     */
    /*
     * copy wifiAssocStaPAcked data
     * set rowreq_ctx->undo->wifiAssocStaPAcked from rowreq_ctx->data.wifiAssocStaPAcked
     */
    rowreq_ctx->undo->wifiAssocStaPAcked = rowreq_ctx->data.wifiAssocStaPAcked;


    return MFD_SUCCESS;
} /* wifiAssocStaPAcked_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPAcked_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPAcked_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPAcked_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPAcked_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPAcked value.
     * set wifiAssocStaPAcked value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPAcked = wifiAssocStaPAcked_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPAcked_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPAcked_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPAcked_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPAcked undo.
     */
    /*
     * copy wifiAssocStaPAcked data
     * set rowreq_ctx->data.wifiAssocStaPAcked from rowreq_ctx->undo->wifiAssocStaPAcked
     */
    rowreq_ctx->data.wifiAssocStaPAcked = rowreq_ctx->undo->wifiAssocStaPAcked;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPAcked_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPTput
 * wifiAssocStaPTput is subid 15 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.15
 * Description:
Packet throughput rate of the STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPTput_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPTput_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPTput_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPTput_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPTput value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPTput value not illegal */
} /* wifiAssocStaPTput_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPTput_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPTput_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPTput undo.
     */
    /*
     * copy wifiAssocStaPTput data
     * set rowreq_ctx->undo->wifiAssocStaPTput from rowreq_ctx->data.wifiAssocStaPTput
     */
    rowreq_ctx->undo->wifiAssocStaPTput = rowreq_ctx->data.wifiAssocStaPTput;


    return MFD_SUCCESS;
} /* wifiAssocStaPTput_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPTput_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPTput_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPTput_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPTput_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPTput value.
     * set wifiAssocStaPTput value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPTput = wifiAssocStaPTput_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPTput_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPTput_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPTput_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPTput undo.
     */
    /*
     * copy wifiAssocStaPTput data
     * set rowreq_ctx->data.wifiAssocStaPTput from rowreq_ctx->undo->wifiAssocStaPTput
     */
    rowreq_ctx->data.wifiAssocStaPTput = rowreq_ctx->undo->wifiAssocStaPTput;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPTput_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaPPhyRate
 * wifiAssocStaPPhyRate is subid 16 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.16
 * Description:
Packet PHY rate of the STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaPPhyRate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaPPhyRate_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPPhyRate_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPhyRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaPPhyRate value.
     */

    return MFD_SUCCESS; /* wifiAssocStaPPhyRate value not illegal */
} /* wifiAssocStaPPhyRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaPPhyRate_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPhyRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaPPhyRate undo.
     */
    /*
     * copy wifiAssocStaPPhyRate data
     * set rowreq_ctx->undo->wifiAssocStaPPhyRate from rowreq_ctx->data.wifiAssocStaPPhyRate
     */
    rowreq_ctx->undo->wifiAssocStaPPhyRate = rowreq_ctx->data.wifiAssocStaPPhyRate;


    return MFD_SUCCESS;
} /* wifiAssocStaPPhyRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaPPhyRate_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaPPhyRate_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaPPhyRate_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPhyRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaPPhyRate value.
     * set wifiAssocStaPPhyRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaPPhyRate = wifiAssocStaPPhyRate_val;

    return MFD_SUCCESS;
} /* wifiAssocStaPPhyRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaPPhyRate_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaPPhyRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaPPhyRate undo.
     */
    /*
     * copy wifiAssocStaPPhyRate data
     * set rowreq_ctx->data.wifiAssocStaPPhyRate from rowreq_ctx->undo->wifiAssocStaPPhyRate
     */
    rowreq_ctx->data.wifiAssocStaPPhyRate = rowreq_ctx->undo->wifiAssocStaPPhyRate;

    
    return MFD_SUCCESS;
} /* wifiAssocStaPPhyRate_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaTxBytes
 * wifiAssocStaTxBytes is subid 17 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.17
 * Description:
Total number of Tx bytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaTxBytes_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaTxBytes_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, U64 wifiAssocStaTxBytes_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxBytes_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaTxBytes value.
     */

    return MFD_SUCCESS; /* wifiAssocStaTxBytes value not illegal */
} /* wifiAssocStaTxBytes_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaTxBytes_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxBytes_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaTxBytes undo.
     */
    /*
     * copy wifiAssocStaTxBytes data
     * set rowreq_ctx->undo->wifiAssocStaTxBytes from rowreq_ctx->data.wifiAssocStaTxBytes
     */
    rowreq_ctx->undo->wifiAssocStaTxBytes = rowreq_ctx->data.wifiAssocStaTxBytes;


    return MFD_SUCCESS;
} /* wifiAssocStaTxBytes_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaTxBytes_val
 *        A U64 containing the new value.
 */
int
wifiAssocStaTxBytes_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, U64 wifiAssocStaTxBytes_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxBytes_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaTxBytes value.
     * set wifiAssocStaTxBytes value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaTxBytes = wifiAssocStaTxBytes_val;

    return MFD_SUCCESS;
} /* wifiAssocStaTxBytes_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaTxBytes_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxBytes_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaTxBytes undo.
     */
    /*
     * copy wifiAssocStaTxBytes data
     * set rowreq_ctx->data.wifiAssocStaTxBytes from rowreq_ctx->undo->wifiAssocStaTxBytes
     */
    rowreq_ctx->data.wifiAssocStaTxBytes = rowreq_ctx->undo->wifiAssocStaTxBytes;

    
    return MFD_SUCCESS;
} /* wifiAssocStaTxBytes_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaRxBytes
 * wifiAssocStaRxBytes is subid 18 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.18
 * Description:
Total number of Rx bytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaRxBytes_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaRxBytes_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, U64 wifiAssocStaRxBytes_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxBytes_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaRxBytes value.
     */

    return MFD_SUCCESS; /* wifiAssocStaRxBytes value not illegal */
} /* wifiAssocStaRxBytes_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaRxBytes_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxBytes_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaRxBytes undo.
     */
    /*
     * copy wifiAssocStaRxBytes data
     * set rowreq_ctx->undo->wifiAssocStaRxBytes from rowreq_ctx->data.wifiAssocStaRxBytes
     */
    rowreq_ctx->undo->wifiAssocStaRxBytes = rowreq_ctx->data.wifiAssocStaRxBytes;


    return MFD_SUCCESS;
} /* wifiAssocStaRxBytes_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaRxBytes_val
 *        A U64 containing the new value.
 */
int
wifiAssocStaRxBytes_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, U64 wifiAssocStaRxBytes_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxBytes_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaRxBytes value.
     * set wifiAssocStaRxBytes value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaRxBytes = wifiAssocStaRxBytes_val;

    return MFD_SUCCESS;
} /* wifiAssocStaRxBytes_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaRxBytes_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxBytes_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaRxBytes undo.
     */
    /*
     * copy wifiAssocStaRxBytes data
     * set rowreq_ctx->data.wifiAssocStaRxBytes from rowreq_ctx->undo->wifiAssocStaRxBytes
     */
    rowreq_ctx->data.wifiAssocStaRxBytes = rowreq_ctx->undo->wifiAssocStaRxBytes;

    
    return MFD_SUCCESS;
} /* wifiAssocStaRxBytes_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaTxRateLimit
 * wifiAssocStaTxRateLimit is subid 19 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.19
 * Description:
Max bytes of Tx packets per second. Feature disabled if value is DEFVAL (4294967295)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 4294967295
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaTxRateLimit_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaTxRateLimit_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaTxRateLimit_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxRateLimit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaTxRateLimit value.
     */

    return MFD_SUCCESS; /* wifiAssocStaTxRateLimit value not illegal */
} /* wifiAssocStaTxRateLimit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaTxRateLimit_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxRateLimit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaTxRateLimit undo.
     */
    /*
     * copy wifiAssocStaTxRateLimit data
     * set rowreq_ctx->undo->wifiAssocStaTxRateLimit from rowreq_ctx->data.wifiAssocStaTxRateLimit
     */
    rowreq_ctx->undo->wifiAssocStaTxRateLimit = rowreq_ctx->data.wifiAssocStaTxRateLimit;


    return MFD_SUCCESS;
} /* wifiAssocStaTxRateLimit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaTxRateLimit_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaTxRateLimit_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaTxRateLimit_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxRateLimit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaTxRateLimit value.
     * set wifiAssocStaTxRateLimit value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaTxRateLimit = wifiAssocStaTxRateLimit_val;

    return MFD_SUCCESS;
} /* wifiAssocStaTxRateLimit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaTxRateLimit_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaTxRateLimit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaTxRateLimit undo.
     */
    /*
     * copy wifiAssocStaTxRateLimit data
     * set rowreq_ctx->data.wifiAssocStaTxRateLimit from rowreq_ctx->undo->wifiAssocStaTxRateLimit
     */
    rowreq_ctx->data.wifiAssocStaTxRateLimit = rowreq_ctx->undo->wifiAssocStaTxRateLimit;

    
    return MFD_SUCCESS;
} /* wifiAssocStaTxRateLimit_undo */

/*---------------------------------------------------------------------
 * BRCM-WIFI-MGMT-MIB::wifiAssocStaEntry.wifiAssocStaRxRateLimit
 * wifiAssocStaRxRateLimit is subid 20 of wifiAssocStaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.18.1.5.3.1.20
 * Description:
Max bytes of Rx packets per second. Feature disabled if value is DEFVAL (4294967295)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 4294967295
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wifiAssocStaRxRateLimit_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wifiAssocStaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wifiAssocStaRxRateLimit_check_value( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaRxRateLimit_val)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxRateLimit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wifiAssocStaRxRateLimit value.
     */

    return MFD_SUCCESS; /* wifiAssocStaRxRateLimit value not illegal */
} /* wifiAssocStaRxRateLimit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wifiAssocStaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wifiAssocStaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wifiAssocStaRxRateLimit_undo_setup( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxRateLimit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wifiAssocStaRxRateLimit undo.
     */
    /*
     * copy wifiAssocStaRxRateLimit data
     * set rowreq_ctx->undo->wifiAssocStaRxRateLimit from rowreq_ctx->data.wifiAssocStaRxRateLimit
     */
    rowreq_ctx->undo->wifiAssocStaRxRateLimit = rowreq_ctx->data.wifiAssocStaRxRateLimit;


    return MFD_SUCCESS;
} /* wifiAssocStaRxRateLimit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wifiAssocStaRxRateLimit_val
 *        A u_long containing the new value.
 */
int
wifiAssocStaRxRateLimit_set( wifiAssocStaTable_rowreq_ctx *rowreq_ctx, u_long wifiAssocStaRxRateLimit_val )
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxRateLimit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wifiAssocStaRxRateLimit value.
     * set wifiAssocStaRxRateLimit value in rowreq_ctx->data
     */
    rowreq_ctx->data.wifiAssocStaRxRateLimit = wifiAssocStaRxRateLimit_val;

    return MFD_SUCCESS;
} /* wifiAssocStaRxRateLimit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wifiAssocStaRxRateLimit_undo( wifiAssocStaTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wifiAssocStaTable:wifiAssocStaRxRateLimit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wifiAssocStaRxRateLimit undo.
     */
    /*
     * copy wifiAssocStaRxRateLimit data
     * set rowreq_ctx->data.wifiAssocStaRxRateLimit from rowreq_ctx->undo->wifiAssocStaRxRateLimit
     */
    rowreq_ctx->data.wifiAssocStaRxRateLimit = rowreq_ctx->undo->wifiAssocStaRxRateLimit;

    
    return MFD_SUCCESS;
} /* wifiAssocStaRxRateLimit_undo */

/** @} */
