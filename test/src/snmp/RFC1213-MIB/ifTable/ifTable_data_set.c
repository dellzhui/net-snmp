/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "ifTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ifTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * RFC1213-MIB::ifTable is subid 2 of interfaces.
 * Its status is Mandatory.
 * OID: .1.3.6.1.2.1.2.2, length: 8
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ifTable_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifTable:ifTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup ifTable undo.
     * set up ifTable undo information, in preparation for a set.
     * Undo storage is in (* ifSpecific_val_ptr_ptr )*
     */

    return rc;
} /* ifTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ifTable_undo( ifTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifTable:ifTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> ifTable undo.
     * ifTable undo information, in response to a failed set.
     * Undo storage is in (* ifSpecific_val_ptr_ptr )*
     */

    return rc;
} /* ifTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifTable_undo_cleanup( ifTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifTable:ifTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup ifTable undo.
     * Undo storage is in (* ifSpecific_val_ptr_ptr )*
     */

    return rc;
} /* ifTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ifTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ifTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifTable_commit( ifTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:ifTable:ifTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit ifTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_IFDESCR_FLAG) {
       save_flags &= ~COLUMN_IFDESCR_FLAG; /* clear ifDescr */
       /*
        * TODO:482:o: |-> commit column ifDescr.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifDescr commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifDescr
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFDESCR_FLAG;
       }
    }

    if (save_flags & COLUMN_IFTYPE_FLAG) {
       save_flags &= ~COLUMN_IFTYPE_FLAG; /* clear ifType */
       /*
        * TODO:482:o: |-> commit column ifType.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifType commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifType
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFTYPE_FLAG;
       }
    }

    if (save_flags & COLUMN_IFMTU_FLAG) {
       save_flags &= ~COLUMN_IFMTU_FLAG; /* clear ifMtu */
       /*
        * TODO:482:o: |-> commit column ifMtu.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifMtu commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifMtu
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFMTU_FLAG;
       }
    }

    if (save_flags & COLUMN_IFSPEED_FLAG) {
       save_flags &= ~COLUMN_IFSPEED_FLAG; /* clear ifSpeed */
       /*
        * TODO:482:o: |-> commit column ifSpeed.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifSpeed commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifSpeed
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFSPEED_FLAG;
       }
    }

    if (save_flags & COLUMN_IFPHYSADDRESS_FLAG) {
       save_flags &= ~COLUMN_IFPHYSADDRESS_FLAG; /* clear ifPhysAddress */
       /*
        * TODO:482:o: |-> commit column ifPhysAddress.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifPhysAddress commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifPhysAddress
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFPHYSADDRESS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFADMINSTATUS_FLAG) {
       save_flags &= ~COLUMN_IFADMINSTATUS_FLAG; /* clear ifAdminStatus */
       /*
        * TODO:482:o: |-> commit column ifAdminStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifAdminStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifAdminStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFADMINSTATUS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOPERSTATUS_FLAG) {
       save_flags &= ~COLUMN_IFOPERSTATUS_FLAG; /* clear ifOperStatus */
       /*
        * TODO:482:o: |-> commit column ifOperStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOperStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOperStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOPERSTATUS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFLASTCHANGE_FLAG) {
       save_flags &= ~COLUMN_IFLASTCHANGE_FLAG; /* clear ifLastChange */
       /*
        * TODO:482:o: |-> commit column ifLastChange.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifLastChange commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifLastChange
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFLASTCHANGE_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINOCTETS_FLAG) {
       save_flags &= ~COLUMN_IFINOCTETS_FLAG; /* clear ifInOctets */
       /*
        * TODO:482:o: |-> commit column ifInOctets.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInOctets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInOctets
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINOCTETS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFINUCASTPKTS_FLAG; /* clear ifInUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifInUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINNUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFINNUCASTPKTS_FLAG; /* clear ifInNUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifInNUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInNUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInNUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINNUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINDISCARDS_FLAG) {
       save_flags &= ~COLUMN_IFINDISCARDS_FLAG; /* clear ifInDiscards */
       /*
        * TODO:482:o: |-> commit column ifInDiscards.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInDiscards commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInDiscards
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINDISCARDS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINERRORS_FLAG) {
       save_flags &= ~COLUMN_IFINERRORS_FLAG; /* clear ifInErrors */
       /*
        * TODO:482:o: |-> commit column ifInErrors.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInErrors commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInErrors
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINERRORS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINUNKNOWNPROTOS_FLAG) {
       save_flags &= ~COLUMN_IFINUNKNOWNPROTOS_FLAG; /* clear ifInUnknownProtos */
       /*
        * TODO:482:o: |-> commit column ifInUnknownProtos.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifInUnknownProtos commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInUnknownProtos
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINUNKNOWNPROTOS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTOCTETS_FLAG) {
       save_flags &= ~COLUMN_IFOUTOCTETS_FLAG; /* clear ifOutOctets */
       /*
        * TODO:482:o: |-> commit column ifOutOctets.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutOctets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutOctets
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTOCTETS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFOUTUCASTPKTS_FLAG; /* clear ifOutUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifOutUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTNUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFOUTNUCASTPKTS_FLAG; /* clear ifOutNUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifOutNUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutNUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutNUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTNUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTDISCARDS_FLAG) {
       save_flags &= ~COLUMN_IFOUTDISCARDS_FLAG; /* clear ifOutDiscards */
       /*
        * TODO:482:o: |-> commit column ifOutDiscards.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutDiscards commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutDiscards
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTDISCARDS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTERRORS_FLAG) {
       save_flags &= ~COLUMN_IFOUTERRORS_FLAG; /* clear ifOutErrors */
       /*
        * TODO:482:o: |-> commit column ifOutErrors.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutErrors commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutErrors
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTERRORS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTQLEN_FLAG) {
       save_flags &= ~COLUMN_IFOUTQLEN_FLAG; /* clear ifOutQLen */
       /*
        * TODO:482:o: |-> commit column ifOutQLen.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifOutQLen commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutQLen
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTQLEN_FLAG;
       }
    }

    if (save_flags & COLUMN_IFSPECIFIC_FLAG) {
       save_flags &= ~COLUMN_IFSPECIFIC_FLAG; /* clear ifSpecific */
       /*
        * TODO:482:o: |-> commit column ifSpecific.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifTable column ifSpecific commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifSpecific
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFSPECIFIC_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* ifTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ifTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ifTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifTable_undo_commit( ifTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifTable:ifTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo ifTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* ifTable_undo_commit */

/*
 * TODO:440:M: Implement ifTable node value checks.
 * TODO:450:M: Implement ifTable undo functions.
 * TODO:460:M: Implement ifTable set functions.
 * TODO:480:M: Implement ifTable commit functions.
 */
/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifDescr
 * ifDescr is subid 2 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.2
 * Description:
A textual string containing information about the
            interface.  This string should include the name of
            the manufacturer, the product name and the version
            of the hardware interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifDescr_val_ptr
 *        A char containing the new value.
 * @param ifDescr_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifDescr_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.ifDescr).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifDescr_check_value( ifTable_rowreq_ctx *rowreq_ctx, char *ifDescr_val_ptr,  size_t ifDescr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ifTable:ifDescr_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifDescr_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ifDescr value.
     */

    return MFD_SUCCESS; /* ifDescr value not illegal */
} /* ifDescr_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifDescr_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifDescr_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifDescr undo.
     */
    /*
     * copy ifDescr and ifDescr_len data
     * set rowreq_ctx->undo->ifDescr from rowreq_ctx->data.ifDescr
     */
    memcpy( rowreq_ctx->undo->ifDescr, rowreq_ctx->data.ifDescr,
            (rowreq_ctx->data.ifDescr_len * sizeof(rowreq_ctx->undo->ifDescr[0])));
    rowreq_ctx->undo->ifDescr_len = rowreq_ctx->data.ifDescr_len;


    return MFD_SUCCESS;
} /* ifDescr_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifDescr_val_ptr
 *        A char containing the new value.
 * @param ifDescr_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifDescr_val_ptr
 */
int
ifDescr_set( ifTable_rowreq_ctx *rowreq_ctx, char *ifDescr_val_ptr,  size_t ifDescr_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ifTable:ifDescr_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifDescr_val_ptr);

    /*
     * TODO:461:M: |-> Set ifDescr value.
     * set ifDescr value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ifDescr, ifDescr_val_ptr, ifDescr_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.ifDescr_len = ifDescr_val_ptr_len / sizeof(ifDescr_val_ptr[0]);

    return MFD_SUCCESS;
} /* ifDescr_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifDescr_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifDescr_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifDescr undo.
     */
    /*
     * copy ifDescr and ifDescr_len data
     * set rowreq_ctx->data.ifDescr from rowreq_ctx->undo->ifDescr
     */
    memcpy( rowreq_ctx->data.ifDescr, rowreq_ctx->undo->ifDescr,
            (rowreq_ctx->undo->ifDescr_len * sizeof(rowreq_ctx->data.ifDescr[0])));
    rowreq_ctx->data.ifDescr_len = rowreq_ctx->undo->ifDescr_len;

    
    return MFD_SUCCESS;
} /* ifDescr_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifType
 * ifType is subid 3 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.3
 * Description:
The type of interface, distinguished according to
            the physical/link protocol(s) immediately `below'
            the network layer in the protocol stack.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 27/64. Values:  other(1), regular1822(2), hdh1822(3), ddn_x25(4), rfc877_x25(5), ethernet_csmacd(6), iso88023_csmacd(7), iso88024_tokenBus(8), iso88025_tokenRing(9), iso88026_man(10), starLan(11), proteon_10Mbit(12), proteon_80Mbit(13), hyperchannel(14), fddi(15), lapb(16), sdlc(17), ds1(18), e1(19), basicISDN(20), primaryISDN(21), propPointToPointSerial(22), ppp(23), softwareLoopback(24), eon(25), ethernet_3Mbit(26), nsip(27), slip(28), ultra(29), ds3(30), sip(31), frame_relay(32)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), regular1822(2), hdh1822(3), ddn_x25(4), rfc877_x25(5), ethernet_csmacd(6), iso88023_csmacd(7), iso88024_tokenBus(8), iso88025_tokenRing(9), iso88026_man(10), starLan(11), proteon_10Mbit(12), proteon_80Mbit(13), hyperchannel(14), fddi(15), lapb(16), sdlc(17), ds1(18), e1(19), basicISDN(20), primaryISDN(21), propPointToPointSerial(22), ppp(23), softwareLoopback(24), eon(25), ethernet_3Mbit(26), nsip(27), slip(28), ultra(29), ds3(30), sip(31), frame_relay(32)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifType_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifType_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifType_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifType value.
     */

    return MFD_SUCCESS; /* ifType value not illegal */
} /* ifType_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifType_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifType_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifType undo.
     */
    /*
     * copy ifType data
     * set rowreq_ctx->undo->ifType from rowreq_ctx->data.ifType
     */
    rowreq_ctx->undo->ifType = rowreq_ctx->data.ifType;


    return MFD_SUCCESS;
} /* ifType_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifType_val
 *        A long containing the new value.
 */
int
ifType_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifType_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifType_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifType value.
     * set ifType value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifType = ifType_val;

    return MFD_SUCCESS;
} /* ifType_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifType_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifType_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifType undo.
     */
    /*
     * copy ifType data
     * set rowreq_ctx->data.ifType from rowreq_ctx->undo->ifType
     */
    rowreq_ctx->data.ifType = rowreq_ctx->undo->ifType;

    
    return MFD_SUCCESS;
} /* ifType_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifMtu
 * ifMtu is subid 4 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.4
 * Description:
The size of the largest datagram which can be
            sent/received on the interface, specified in
            octets.  For interfaces that are used for
            transmitting network datagrams, this is the size
            of the largest network datagram that can be sent
            on the interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifMtu_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifMtu_check_value( ifTable_rowreq_ctx *rowreq_ctx, long ifMtu_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifMtu_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifMtu value.
     */

    return MFD_SUCCESS; /* ifMtu value not illegal */
} /* ifMtu_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifMtu_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifMtu_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifMtu undo.
     */
    /*
     * copy ifMtu data
     * set rowreq_ctx->undo->ifMtu from rowreq_ctx->data.ifMtu
     */
    rowreq_ctx->undo->ifMtu = rowreq_ctx->data.ifMtu;


    return MFD_SUCCESS;
} /* ifMtu_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifMtu_val
 *        A long containing the new value.
 */
int
ifMtu_set( ifTable_rowreq_ctx *rowreq_ctx, long ifMtu_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifMtu_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifMtu value.
     * set ifMtu value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifMtu = ifMtu_val;

    return MFD_SUCCESS;
} /* ifMtu_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifMtu_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifMtu_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifMtu undo.
     */
    /*
     * copy ifMtu data
     * set rowreq_ctx->data.ifMtu from rowreq_ctx->undo->ifMtu
     */
    rowreq_ctx->data.ifMtu = rowreq_ctx->undo->ifMtu;

    
    return MFD_SUCCESS;
} /* ifMtu_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifSpeed
 * ifSpeed is subid 5 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.5
 * Description:
An estimate of the interface's current bandwidth
            in bits per second.  For interfaces which do not
            vary in bandwidth or for those where no accurate
            estimation can be made, this object should contain
            the nominal bandwidth.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifSpeed_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_GAUGE
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifSpeed_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifSpeed_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifSpeed_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifSpeed value.
     */

    return MFD_SUCCESS; /* ifSpeed value not illegal */
} /* ifSpeed_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifSpeed_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifSpeed_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifSpeed undo.
     */
    /*
     * copy ifSpeed data
     * set rowreq_ctx->undo->ifSpeed from rowreq_ctx->data.ifSpeed
     */
    rowreq_ctx->undo->ifSpeed = rowreq_ctx->data.ifSpeed;


    return MFD_SUCCESS;
} /* ifSpeed_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifSpeed_val
 *        A u_long containing the new value.
 */
int
ifSpeed_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifSpeed_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifSpeed_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifSpeed value.
     * set ifSpeed value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifSpeed = ifSpeed_val;

    return MFD_SUCCESS;
} /* ifSpeed_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifSpeed_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifSpeed_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifSpeed undo.
     */
    /*
     * copy ifSpeed data
     * set rowreq_ctx->data.ifSpeed from rowreq_ctx->undo->ifSpeed
     */
    rowreq_ctx->data.ifSpeed = rowreq_ctx->undo->ifSpeed;

    
    return MFD_SUCCESS;
} /* ifSpeed_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifPhysAddress
 * ifPhysAddress is subid 6 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.6
 * Description:
The interface's address at the protocol layer
            immediately `below' the network layer in the
            protocol stack.  For interfaces which do not have

            such an address (e.g., a serial line), this object
            should contain an octet string of zero length.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifPhysAddress_val_ptr
 *        A char containing the new value.
 * @param ifPhysAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifPhysAddress_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.ifPhysAddress).
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifPhysAddress_check_value( ifTable_rowreq_ctx *rowreq_ctx, char *ifPhysAddress_val_ptr,  size_t ifPhysAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ifTable:ifPhysAddress_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifPhysAddress_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ifPhysAddress value.
     */

    return MFD_SUCCESS; /* ifPhysAddress value not illegal */
} /* ifPhysAddress_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifPhysAddress_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifPhysAddress_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifPhysAddress undo.
     */
    /*
     * copy ifPhysAddress and ifPhysAddress_len data
     * set rowreq_ctx->undo->ifPhysAddress from rowreq_ctx->data.ifPhysAddress
     */
    memcpy( rowreq_ctx->undo->ifPhysAddress, rowreq_ctx->data.ifPhysAddress,
            (rowreq_ctx->data.ifPhysAddress_len * sizeof(rowreq_ctx->undo->ifPhysAddress[0])));
    rowreq_ctx->undo->ifPhysAddress_len = rowreq_ctx->data.ifPhysAddress_len;


    return MFD_SUCCESS;
} /* ifPhysAddress_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifPhysAddress_val_ptr
 *        A char containing the new value.
 * @param ifPhysAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifPhysAddress_val_ptr
 */
int
ifPhysAddress_set( ifTable_rowreq_ctx *rowreq_ctx, char *ifPhysAddress_val_ptr,  size_t ifPhysAddress_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ifTable:ifPhysAddress_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifPhysAddress_val_ptr);

    /*
     * TODO:461:M: |-> Set ifPhysAddress value.
     * set ifPhysAddress value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ifPhysAddress, ifPhysAddress_val_ptr, ifPhysAddress_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.ifPhysAddress_len = ifPhysAddress_val_ptr_len / sizeof(ifPhysAddress_val_ptr[0]);

    return MFD_SUCCESS;
} /* ifPhysAddress_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifPhysAddress_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifPhysAddress_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifPhysAddress undo.
     */
    /*
     * copy ifPhysAddress and ifPhysAddress_len data
     * set rowreq_ctx->data.ifPhysAddress from rowreq_ctx->undo->ifPhysAddress
     */
    memcpy( rowreq_ctx->data.ifPhysAddress, rowreq_ctx->undo->ifPhysAddress,
            (rowreq_ctx->undo->ifPhysAddress_len * sizeof(rowreq_ctx->data.ifPhysAddress[0])));
    rowreq_ctx->data.ifPhysAddress_len = rowreq_ctx->undo->ifPhysAddress_len;

    
    return MFD_SUCCESS;
} /* ifPhysAddress_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifAdminStatus
 * ifAdminStatus is subid 7 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.7
 * Description:
The desired state of the interface.  The
            testing(3) state indicates that no operational
            packets can be passed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  up(1), down(2), testing(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifAdminStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  up(1), down(2), testing(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifAdminStatus_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifAdminStatus_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifAdminStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifAdminStatus value.
     */

    return MFD_SUCCESS; /* ifAdminStatus value not illegal */
} /* ifAdminStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifAdminStatus_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifAdminStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifAdminStatus undo.
     */
    /*
     * copy ifAdminStatus data
     * set rowreq_ctx->undo->ifAdminStatus from rowreq_ctx->data.ifAdminStatus
     */
    rowreq_ctx->undo->ifAdminStatus = rowreq_ctx->data.ifAdminStatus;


    return MFD_SUCCESS;
} /* ifAdminStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifAdminStatus_val
 *        A long containing the new value.
 */
int
ifAdminStatus_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifAdminStatus_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifAdminStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifAdminStatus value.
     * set ifAdminStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifAdminStatus = ifAdminStatus_val;

    return MFD_SUCCESS;
} /* ifAdminStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifAdminStatus_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifAdminStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifAdminStatus undo.
     */
    /*
     * copy ifAdminStatus data
     * set rowreq_ctx->data.ifAdminStatus from rowreq_ctx->undo->ifAdminStatus
     */
    rowreq_ctx->data.ifAdminStatus = rowreq_ctx->undo->ifAdminStatus;

    
    return MFD_SUCCESS;
} /* ifAdminStatus_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOperStatus
 * ifOperStatus is subid 8 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.8
 * Description:
The current operational state of the interface.
            The testing(3) state indicates that no operational
            packets can be passed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  up(1), down(2), testing(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOperStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  up(1), down(2), testing(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOperStatus_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOperStatus_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOperStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOperStatus value.
     */

    return MFD_SUCCESS; /* ifOperStatus value not illegal */
} /* ifOperStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOperStatus_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOperStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOperStatus undo.
     */
    /*
     * copy ifOperStatus data
     * set rowreq_ctx->undo->ifOperStatus from rowreq_ctx->data.ifOperStatus
     */
    rowreq_ctx->undo->ifOperStatus = rowreq_ctx->data.ifOperStatus;


    return MFD_SUCCESS;
} /* ifOperStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOperStatus_val
 *        A long containing the new value.
 */
int
ifOperStatus_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOperStatus_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOperStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOperStatus value.
     * set ifOperStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOperStatus = ifOperStatus_val;

    return MFD_SUCCESS;
} /* ifOperStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOperStatus_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOperStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOperStatus undo.
     */
    /*
     * copy ifOperStatus data
     * set rowreq_ctx->data.ifOperStatus from rowreq_ctx->undo->ifOperStatus
     */
    rowreq_ctx->data.ifOperStatus = rowreq_ctx->undo->ifOperStatus;

    
    return MFD_SUCCESS;
} /* ifOperStatus_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifLastChange
 * ifLastChange is subid 9 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.9
 * Description:
The value of sysUpTime at the time the interface
            entered its current operational state.  If the
            current state was entered prior to the last re-
            initialization of the local network management
            subsystem, then this object contains a zero
            value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifLastChange_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_TIMETICKS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifLastChange_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifLastChange_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifLastChange_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifLastChange value.
     */

    return MFD_SUCCESS; /* ifLastChange value not illegal */
} /* ifLastChange_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifLastChange_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifLastChange_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifLastChange undo.
     */
    /*
     * copy ifLastChange data
     * set rowreq_ctx->undo->ifLastChange from rowreq_ctx->data.ifLastChange
     */
    rowreq_ctx->undo->ifLastChange = rowreq_ctx->data.ifLastChange;


    return MFD_SUCCESS;
} /* ifLastChange_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifLastChange_val
 *        A u_long containing the new value.
 */
int
ifLastChange_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifLastChange_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifLastChange_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifLastChange value.
     * set ifLastChange value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifLastChange = ifLastChange_val;

    return MFD_SUCCESS;
} /* ifLastChange_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifLastChange_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifLastChange_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifLastChange undo.
     */
    /*
     * copy ifLastChange data
     * set rowreq_ctx->data.ifLastChange from rowreq_ctx->undo->ifLastChange
     */
    rowreq_ctx->data.ifLastChange = rowreq_ctx->undo->ifLastChange;

    
    return MFD_SUCCESS;
} /* ifLastChange_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInOctets
 * ifInOctets is subid 10 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.10
 * Description:
The total number of octets received on the
            interface, including framing characters.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInOctets_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInOctets_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInOctets_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInOctets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInOctets value.
     */

    return MFD_SUCCESS; /* ifInOctets value not illegal */
} /* ifInOctets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInOctets_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInOctets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInOctets undo.
     */
    /*
     * copy ifInOctets data
     * set rowreq_ctx->undo->ifInOctets from rowreq_ctx->data.ifInOctets
     */
    rowreq_ctx->undo->ifInOctets = rowreq_ctx->data.ifInOctets;


    return MFD_SUCCESS;
} /* ifInOctets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInOctets_val
 *        A u_long containing the new value.
 */
int
ifInOctets_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInOctets_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInOctets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInOctets value.
     * set ifInOctets value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInOctets = ifInOctets_val;

    return MFD_SUCCESS;
} /* ifInOctets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInOctets_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInOctets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInOctets undo.
     */
    /*
     * copy ifInOctets data
     * set rowreq_ctx->data.ifInOctets from rowreq_ctx->undo->ifInOctets
     */
    rowreq_ctx->data.ifInOctets = rowreq_ctx->undo->ifInOctets;

    
    return MFD_SUCCESS;
} /* ifInOctets_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInUcastPkts
 * ifInUcastPkts is subid 11 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.11
 * Description:
The number of subnetwork-unicast packets
            delivered to a higher-layer protocol.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInUcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInUcastPkts_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInUcastPkts value.
     */

    return MFD_SUCCESS; /* ifInUcastPkts value not illegal */
} /* ifInUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInUcastPkts_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInUcastPkts undo.
     */
    /*
     * copy ifInUcastPkts data
     * set rowreq_ctx->undo->ifInUcastPkts from rowreq_ctx->data.ifInUcastPkts
     */
    rowreq_ctx->undo->ifInUcastPkts = rowreq_ctx->data.ifInUcastPkts;


    return MFD_SUCCESS;
} /* ifInUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInUcastPkts_val
 *        A u_long containing the new value.
 */
int
ifInUcastPkts_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInUcastPkts value.
     * set ifInUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInUcastPkts = ifInUcastPkts_val;

    return MFD_SUCCESS;
} /* ifInUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInUcastPkts_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInUcastPkts undo.
     */
    /*
     * copy ifInUcastPkts data
     * set rowreq_ctx->data.ifInUcastPkts from rowreq_ctx->undo->ifInUcastPkts
     */
    rowreq_ctx->data.ifInUcastPkts = rowreq_ctx->undo->ifInUcastPkts;

    
    return MFD_SUCCESS;
} /* ifInUcastPkts_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInNUcastPkts
 * ifInNUcastPkts is subid 12 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.12
 * Description:
The number of non-unicast (i.e., subnetwork-
            broadcast or subnetwork-multicast) packets
            delivered to a higher-layer protocol.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInNUcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInNUcastPkts_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInNUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInNUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInNUcastPkts value.
     */

    return MFD_SUCCESS; /* ifInNUcastPkts value not illegal */
} /* ifInNUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInNUcastPkts_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInNUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInNUcastPkts undo.
     */
    /*
     * copy ifInNUcastPkts data
     * set rowreq_ctx->undo->ifInNUcastPkts from rowreq_ctx->data.ifInNUcastPkts
     */
    rowreq_ctx->undo->ifInNUcastPkts = rowreq_ctx->data.ifInNUcastPkts;


    return MFD_SUCCESS;
} /* ifInNUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInNUcastPkts_val
 *        A u_long containing the new value.
 */
int
ifInNUcastPkts_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInNUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInNUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInNUcastPkts value.
     * set ifInNUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInNUcastPkts = ifInNUcastPkts_val;

    return MFD_SUCCESS;
} /* ifInNUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInNUcastPkts_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInNUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInNUcastPkts undo.
     */
    /*
     * copy ifInNUcastPkts data
     * set rowreq_ctx->data.ifInNUcastPkts from rowreq_ctx->undo->ifInNUcastPkts
     */
    rowreq_ctx->data.ifInNUcastPkts = rowreq_ctx->undo->ifInNUcastPkts;

    
    return MFD_SUCCESS;
} /* ifInNUcastPkts_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInDiscards
 * ifInDiscards is subid 13 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.13
 * Description:
The number of inbound packets which were chosen
            to be discarded even though no errors had been
            detected to prevent their being deliverable to a
            higher-layer protocol.  One possible reason for
            discarding such a packet could be to free up
            buffer space.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInDiscards_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInDiscards_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInDiscards_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInDiscards_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInDiscards value.
     */

    return MFD_SUCCESS; /* ifInDiscards value not illegal */
} /* ifInDiscards_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInDiscards_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInDiscards_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInDiscards undo.
     */
    /*
     * copy ifInDiscards data
     * set rowreq_ctx->undo->ifInDiscards from rowreq_ctx->data.ifInDiscards
     */
    rowreq_ctx->undo->ifInDiscards = rowreq_ctx->data.ifInDiscards;


    return MFD_SUCCESS;
} /* ifInDiscards_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInDiscards_val
 *        A u_long containing the new value.
 */
int
ifInDiscards_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInDiscards_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInDiscards_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInDiscards value.
     * set ifInDiscards value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInDiscards = ifInDiscards_val;

    return MFD_SUCCESS;
} /* ifInDiscards_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInDiscards_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInDiscards_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInDiscards undo.
     */
    /*
     * copy ifInDiscards data
     * set rowreq_ctx->data.ifInDiscards from rowreq_ctx->undo->ifInDiscards
     */
    rowreq_ctx->data.ifInDiscards = rowreq_ctx->undo->ifInDiscards;

    
    return MFD_SUCCESS;
} /* ifInDiscards_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInErrors
 * ifInErrors is subid 14 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.14
 * Description:
The number of inbound packets that contained
            errors preventing them from being deliverable to a
            higher-layer protocol.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInErrors_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInErrors_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInErrors_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInErrors_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInErrors value.
     */

    return MFD_SUCCESS; /* ifInErrors value not illegal */
} /* ifInErrors_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInErrors_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInErrors_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInErrors undo.
     */
    /*
     * copy ifInErrors data
     * set rowreq_ctx->undo->ifInErrors from rowreq_ctx->data.ifInErrors
     */
    rowreq_ctx->undo->ifInErrors = rowreq_ctx->data.ifInErrors;


    return MFD_SUCCESS;
} /* ifInErrors_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInErrors_val
 *        A u_long containing the new value.
 */
int
ifInErrors_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInErrors_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInErrors_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInErrors value.
     * set ifInErrors value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInErrors = ifInErrors_val;

    return MFD_SUCCESS;
} /* ifInErrors_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInErrors_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInErrors_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInErrors undo.
     */
    /*
     * copy ifInErrors data
     * set rowreq_ctx->data.ifInErrors from rowreq_ctx->undo->ifInErrors
     */
    rowreq_ctx->data.ifInErrors = rowreq_ctx->undo->ifInErrors;

    
    return MFD_SUCCESS;
} /* ifInErrors_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifInUnknownProtos
 * ifInUnknownProtos is subid 15 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.15
 * Description:
The number of packets received via the interface
            which were discarded because of an unknown or
            unsupported protocol.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInUnknownProtos_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInUnknownProtos_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInUnknownProtos_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifInUnknownProtos_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInUnknownProtos value.
     */

    return MFD_SUCCESS; /* ifInUnknownProtos value not illegal */
} /* ifInUnknownProtos_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInUnknownProtos_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifInUnknownProtos_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInUnknownProtos undo.
     */
    /*
     * copy ifInUnknownProtos data
     * set rowreq_ctx->undo->ifInUnknownProtos from rowreq_ctx->data.ifInUnknownProtos
     */
    rowreq_ctx->undo->ifInUnknownProtos = rowreq_ctx->data.ifInUnknownProtos;


    return MFD_SUCCESS;
} /* ifInUnknownProtos_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInUnknownProtos_val
 *        A u_long containing the new value.
 */
int
ifInUnknownProtos_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifInUnknownProtos_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifInUnknownProtos_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInUnknownProtos value.
     * set ifInUnknownProtos value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInUnknownProtos = ifInUnknownProtos_val;

    return MFD_SUCCESS;
} /* ifInUnknownProtos_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInUnknownProtos_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifInUnknownProtos_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInUnknownProtos undo.
     */
    /*
     * copy ifInUnknownProtos data
     * set rowreq_ctx->data.ifInUnknownProtos from rowreq_ctx->undo->ifInUnknownProtos
     */
    rowreq_ctx->data.ifInUnknownProtos = rowreq_ctx->undo->ifInUnknownProtos;

    
    return MFD_SUCCESS;
} /* ifInUnknownProtos_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutOctets
 * ifOutOctets is subid 16 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.16
 * Description:
The total number of octets transmitted out of the
            interface, including framing characters.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutOctets_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutOctets_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutOctets_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutOctets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutOctets value.
     */

    return MFD_SUCCESS; /* ifOutOctets value not illegal */
} /* ifOutOctets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutOctets_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutOctets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutOctets undo.
     */
    /*
     * copy ifOutOctets data
     * set rowreq_ctx->undo->ifOutOctets from rowreq_ctx->data.ifOutOctets
     */
    rowreq_ctx->undo->ifOutOctets = rowreq_ctx->data.ifOutOctets;


    return MFD_SUCCESS;
} /* ifOutOctets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutOctets_val
 *        A u_long containing the new value.
 */
int
ifOutOctets_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutOctets_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutOctets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutOctets value.
     * set ifOutOctets value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutOctets = ifOutOctets_val;

    return MFD_SUCCESS;
} /* ifOutOctets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutOctets_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutOctets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutOctets undo.
     */
    /*
     * copy ifOutOctets data
     * set rowreq_ctx->data.ifOutOctets from rowreq_ctx->undo->ifOutOctets
     */
    rowreq_ctx->data.ifOutOctets = rowreq_ctx->undo->ifOutOctets;

    
    return MFD_SUCCESS;
} /* ifOutOctets_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutUcastPkts
 * ifOutUcastPkts is subid 17 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.17
 * Description:
The total number of packets that higher-level
            protocols requested be transmitted to a
            subnetwork-unicast address, including those that
            were discarded or not sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutUcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutUcastPkts_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutUcastPkts value.
     */

    return MFD_SUCCESS; /* ifOutUcastPkts value not illegal */
} /* ifOutUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutUcastPkts_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutUcastPkts undo.
     */
    /*
     * copy ifOutUcastPkts data
     * set rowreq_ctx->undo->ifOutUcastPkts from rowreq_ctx->data.ifOutUcastPkts
     */
    rowreq_ctx->undo->ifOutUcastPkts = rowreq_ctx->data.ifOutUcastPkts;


    return MFD_SUCCESS;
} /* ifOutUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutUcastPkts_val
 *        A u_long containing the new value.
 */
int
ifOutUcastPkts_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutUcastPkts value.
     * set ifOutUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutUcastPkts = ifOutUcastPkts_val;

    return MFD_SUCCESS;
} /* ifOutUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutUcastPkts_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutUcastPkts undo.
     */
    /*
     * copy ifOutUcastPkts data
     * set rowreq_ctx->data.ifOutUcastPkts from rowreq_ctx->undo->ifOutUcastPkts
     */
    rowreq_ctx->data.ifOutUcastPkts = rowreq_ctx->undo->ifOutUcastPkts;

    
    return MFD_SUCCESS;
} /* ifOutUcastPkts_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutNUcastPkts
 * ifOutNUcastPkts is subid 18 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.18
 * Description:
The total number of packets that higher-level
            protocols requested be transmitted to a non-
            unicast (i.e., a subnetwork-broadcast or
            subnetwork-multicast) address, including those
            that were discarded or not sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutNUcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutNUcastPkts_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutNUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutNUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutNUcastPkts value.
     */

    return MFD_SUCCESS; /* ifOutNUcastPkts value not illegal */
} /* ifOutNUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutNUcastPkts_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutNUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutNUcastPkts undo.
     */
    /*
     * copy ifOutNUcastPkts data
     * set rowreq_ctx->undo->ifOutNUcastPkts from rowreq_ctx->data.ifOutNUcastPkts
     */
    rowreq_ctx->undo->ifOutNUcastPkts = rowreq_ctx->data.ifOutNUcastPkts;


    return MFD_SUCCESS;
} /* ifOutNUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutNUcastPkts_val
 *        A u_long containing the new value.
 */
int
ifOutNUcastPkts_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutNUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutNUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutNUcastPkts value.
     * set ifOutNUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutNUcastPkts = ifOutNUcastPkts_val;

    return MFD_SUCCESS;
} /* ifOutNUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutNUcastPkts_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutNUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutNUcastPkts undo.
     */
    /*
     * copy ifOutNUcastPkts data
     * set rowreq_ctx->data.ifOutNUcastPkts from rowreq_ctx->undo->ifOutNUcastPkts
     */
    rowreq_ctx->data.ifOutNUcastPkts = rowreq_ctx->undo->ifOutNUcastPkts;

    
    return MFD_SUCCESS;
} /* ifOutNUcastPkts_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutDiscards
 * ifOutDiscards is subid 19 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.19
 * Description:
The number of outbound packets which were chosen

            to be discarded even though no errors had been
            detected to prevent their being transmitted.  One
            possible reason for discarding such a packet could
            be to free up buffer space.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutDiscards_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutDiscards_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutDiscards_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutDiscards_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutDiscards value.
     */

    return MFD_SUCCESS; /* ifOutDiscards value not illegal */
} /* ifOutDiscards_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutDiscards_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutDiscards_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutDiscards undo.
     */
    /*
     * copy ifOutDiscards data
     * set rowreq_ctx->undo->ifOutDiscards from rowreq_ctx->data.ifOutDiscards
     */
    rowreq_ctx->undo->ifOutDiscards = rowreq_ctx->data.ifOutDiscards;


    return MFD_SUCCESS;
} /* ifOutDiscards_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutDiscards_val
 *        A u_long containing the new value.
 */
int
ifOutDiscards_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutDiscards_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutDiscards_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutDiscards value.
     * set ifOutDiscards value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutDiscards = ifOutDiscards_val;

    return MFD_SUCCESS;
} /* ifOutDiscards_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutDiscards_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutDiscards_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutDiscards undo.
     */
    /*
     * copy ifOutDiscards data
     * set rowreq_ctx->data.ifOutDiscards from rowreq_ctx->undo->ifOutDiscards
     */
    rowreq_ctx->data.ifOutDiscards = rowreq_ctx->undo->ifOutDiscards;

    
    return MFD_SUCCESS;
} /* ifOutDiscards_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutErrors
 * ifOutErrors is subid 20 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.20
 * Description:
The number of outbound packets that could not be
            transmitted because of errors.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutErrors_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutErrors_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutErrors_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutErrors_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutErrors value.
     */

    return MFD_SUCCESS; /* ifOutErrors value not illegal */
} /* ifOutErrors_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutErrors_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutErrors_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutErrors undo.
     */
    /*
     * copy ifOutErrors data
     * set rowreq_ctx->undo->ifOutErrors from rowreq_ctx->data.ifOutErrors
     */
    rowreq_ctx->undo->ifOutErrors = rowreq_ctx->data.ifOutErrors;


    return MFD_SUCCESS;
} /* ifOutErrors_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutErrors_val
 *        A u_long containing the new value.
 */
int
ifOutErrors_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutErrors_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutErrors_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutErrors value.
     * set ifOutErrors value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutErrors = ifOutErrors_val;

    return MFD_SUCCESS;
} /* ifOutErrors_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutErrors_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutErrors_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutErrors undo.
     */
    /*
     * copy ifOutErrors data
     * set rowreq_ctx->data.ifOutErrors from rowreq_ctx->undo->ifOutErrors
     */
    rowreq_ctx->data.ifOutErrors = rowreq_ctx->undo->ifOutErrors;

    
    return MFD_SUCCESS;
} /* ifOutErrors_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifOutQLen
 * ifOutQLen is subid 21 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.21
 * Description:
The length of the output packet queue (in
            packets).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutQLen_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_GAUGE
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutQLen_check_value( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutQLen_val)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutQLen_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutQLen value.
     */

    return MFD_SUCCESS; /* ifOutQLen value not illegal */
} /* ifOutQLen_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutQLen_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifOutQLen_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutQLen undo.
     */
    /*
     * copy ifOutQLen data
     * set rowreq_ctx->undo->ifOutQLen from rowreq_ctx->data.ifOutQLen
     */
    rowreq_ctx->undo->ifOutQLen = rowreq_ctx->data.ifOutQLen;


    return MFD_SUCCESS;
} /* ifOutQLen_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutQLen_val
 *        A u_long containing the new value.
 */
int
ifOutQLen_set( ifTable_rowreq_ctx *rowreq_ctx, u_long ifOutQLen_val )
{

    DEBUGMSGTL(("verbose:ifTable:ifOutQLen_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutQLen value.
     * set ifOutQLen value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutQLen = ifOutQLen_val;

    return MFD_SUCCESS;
} /* ifOutQLen_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutQLen_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifOutQLen_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutQLen undo.
     */
    /*
     * copy ifOutQLen data
     * set rowreq_ctx->data.ifOutQLen from rowreq_ctx->undo->ifOutQLen
     */
    rowreq_ctx->data.ifOutQLen = rowreq_ctx->undo->ifOutQLen;

    
    return MFD_SUCCESS;
} /* ifOutQLen_undo */

/*---------------------------------------------------------------------
 * RFC1213-MIB::ifEntry.ifSpecific
 * ifSpecific is subid 22 of ifEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.22
 * Description:
A reference to MIB definitions specific to the
            particular media being used to realize the
            interface.  For example, if the interface is
            realized by an ethernet, then the value of this
            object refers to a document defining objects
            specific to ethernet.  If this information is not
            present, its value should be set to the OBJECT
            IDENTIFIER { 0 0 }, which is a syntatically valid
            object identifier, and any conformant
            implementation of ASN.1 and BER must be able to
            generate and recognize this value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifSpecific_val_ptr
 *        A oid containing the new value.
 * @param ifSpecific_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifSpecific_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OBJECT_ID
 *    The length is < sizeof(rowreq_ctx->data.ifSpecific).
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifSpecific_check_value( ifTable_rowreq_ctx *rowreq_ctx, oid *ifSpecific_val_ptr,  size_t ifSpecific_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ifTable:ifSpecific_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifSpecific_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ifSpecific value.
     */

    return MFD_SUCCESS; /* ifSpecific value not illegal */
} /* ifSpecific_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifSpecific_undo_setup( ifTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable:ifSpecific_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifSpecific undo.
     */
    /*
     * copy ifSpecific and ifSpecific_len data
     * set rowreq_ctx->undo->ifSpecific from rowreq_ctx->data.ifSpecific
     */
    memcpy( rowreq_ctx->undo->ifSpecific, rowreq_ctx->data.ifSpecific,
            (rowreq_ctx->data.ifSpecific_len * sizeof(rowreq_ctx->undo->ifSpecific[0])));
    rowreq_ctx->undo->ifSpecific_len = rowreq_ctx->data.ifSpecific_len;


    return MFD_SUCCESS;
} /* ifSpecific_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifSpecific_val_ptr
 *        A oid containing the new value.
 * @param ifSpecific_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifSpecific_val_ptr
 */
int
ifSpecific_set( ifTable_rowreq_ctx *rowreq_ctx, oid *ifSpecific_val_ptr,  size_t ifSpecific_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ifTable:ifSpecific_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifSpecific_val_ptr);

    /*
     * TODO:461:M: |-> Set ifSpecific value.
     * set ifSpecific value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ifSpecific, ifSpecific_val_ptr, ifSpecific_val_ptr_len );
    /** convert bytes to number of oid */
    rowreq_ctx->data.ifSpecific_len = ifSpecific_val_ptr_len / sizeof(ifSpecific_val_ptr[0]);

    return MFD_SUCCESS;
} /* ifSpecific_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifSpecific_undo( ifTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifTable:ifSpecific_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifSpecific undo.
     */
    /*
     * copy ifSpecific and ifSpecific_len data
     * set rowreq_ctx->data.ifSpecific from rowreq_ctx->undo->ifSpecific
     */
    memcpy( rowreq_ctx->data.ifSpecific, rowreq_ctx->undo->ifSpecific,
            (rowreq_ctx->undo->ifSpecific_len * sizeof(rowreq_ctx->data.ifSpecific[0])));
    rowreq_ctx->data.ifSpecific_len = rowreq_ctx->undo->ifSpecific_len;

    
    return MFD_SUCCESS;
} /* ifSpecific_undo */

/** @} */
