/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "clabWIFIRadioTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table clabWIFIRadioTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * CLAB-WIFI-MIB::clabWIFIRadioTable is subid 2 of clabWIFIObjects.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * clabWIFIRadioTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * clabWIFIRadioTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
clabWIFIRadioTable_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup clabWIFIRadioTable undo.
     * set up clabWIFIRadioTable undo information, in preparation for a set.
     * Undo storage is in (* clabWIFIRadioPktErrorRateSTA_val_ptr )*
     */

    return rc;
} /* clabWIFIRadioTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
clabWIFIRadioTable_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> clabWIFIRadioTable undo.
     * clabWIFIRadioTable undo information, in response to a failed set.
     * Undo storage is in (* clabWIFIRadioPktErrorRateSTA_val_ptr )*
     */

    return rc;
} /* clabWIFIRadioTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
clabWIFIRadioTable_undo_cleanup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup clabWIFIRadioTable undo.
     * Undo storage is in (* clabWIFIRadioPktErrorRateSTA_val_ptr )*
     */

    return rc;
} /* clabWIFIRadioTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * clabWIFIRadioTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param clabWIFIRadioTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
clabWIFIRadioTable_commit( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit clabWIFIRadioTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_CLABWIFIRADIOENABLE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOENABLE_FLAG; /* clear clabWIFIRadioEnable */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOSTATUS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOSTATUS_FLAG; /* clear clabWIFIRadioStatus */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOSTATUS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOALIAS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOALIAS_FLAG; /* clear clabWIFIRadioAlias */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioAlias.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioAlias commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioAlias
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOALIAS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIONAME_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIONAME_FLAG; /* clear clabWIFIRadioName */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioName.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioName commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioName
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIONAME_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOLASTCHANGE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOLASTCHANGE_FLAG; /* clear clabWIFIRadioLastChange */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioLastChange.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioLastChange commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioLastChange
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOLASTCHANGE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOLOWERLAYERS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOLOWERLAYERS_FLAG; /* clear clabWIFIRadioLowerLayers */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioLowerLayers.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioLowerLayers commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioLowerLayers
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOLOWERLAYERS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOUPSTREAM_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOUPSTREAM_FLAG; /* clear clabWIFIRadioUpstream */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioUpstream.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioUpstream commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioUpstream
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOUPSTREAM_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOMAXBITRATE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOMAXBITRATE_FLAG; /* clear clabWIFIRadioMaxBitRate */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioMaxBitRate.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioMaxBitRate commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioMaxBitRate
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOMAXBITRATE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOSUPPORTEDFREQUENCYBANDS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOSUPPORTEDFREQUENCYBANDS_FLAG; /* clear clabWIFIRadioSupportedFrequencyBands */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioSupportedFrequencyBands.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioSupportedFrequencyBands commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioSupportedFrequencyBands
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOSUPPORTEDFREQUENCYBANDS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOOPERATINGFREQUENCYBAND_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOOPERATINGFREQUENCYBAND_FLAG; /* clear clabWIFIRadioOperatingFrequencyBand */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioOperatingFrequencyBand.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioOperatingFrequencyBand commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioOperatingFrequencyBand
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOOPERATINGFREQUENCYBAND_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOSUPPORTEDSTANDARDS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOSUPPORTEDSTANDARDS_FLAG; /* clear clabWIFIRadioSupportedStandards */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioSupportedStandards.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioSupportedStandards commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioSupportedStandards
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOSUPPORTEDSTANDARDS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOOPERATINGSTANDARDS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOOPERATINGSTANDARDS_FLAG; /* clear clabWIFIRadioOperatingStandards */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioOperatingStandards.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioOperatingStandards commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioOperatingStandards
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOOPERATINGSTANDARDS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOPOSSIBLECHANNELS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOPOSSIBLECHANNELS_FLAG; /* clear clabWIFIRadioPossibleChannels */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioPossibleChannels.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioPossibleChannels commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioPossibleChannels
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOPOSSIBLECHANNELS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOCHANNELSINUSE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOCHANNELSINUSE_FLAG; /* clear clabWIFIRadioChannelsInUse */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioChannelsInUse.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioChannelsInUse commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioChannelsInUse
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOCHANNELSINUSE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOCHANNEL_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOCHANNEL_FLAG; /* clear clabWIFIRadioChannel */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioChannel.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioChannel commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioChannel
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOCHANNEL_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOAUTOCHANNELSUPPORTED_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOAUTOCHANNELSUPPORTED_FLAG; /* clear clabWIFIRadioAutoChannelSupported */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioAutoChannelSupported.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioAutoChannelSupported commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioAutoChannelSupported
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOAUTOCHANNELSUPPORTED_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOAUTOCHANNELENABLE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOAUTOCHANNELENABLE_FLAG; /* clear clabWIFIRadioAutoChannelEnable */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioAutoChannelEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioAutoChannelEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioAutoChannelEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOAUTOCHANNELENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOAUTOCHANNELREFRESHPERIOD_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOAUTOCHANNELREFRESHPERIOD_FLAG; /* clear clabWIFIRadioAutoChannelRefreshPeriod */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioAutoChannelRefreshPeriod.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioAutoChannelRefreshPeriod commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioAutoChannelRefreshPeriod
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOAUTOCHANNELREFRESHPERIOD_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOOPERATINGCHANNELBANDWIDTH_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOOPERATINGCHANNELBANDWIDTH_FLAG; /* clear clabWIFIRadioOperatingChannelBandwidth */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioOperatingChannelBandwidth.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioOperatingChannelBandwidth commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioOperatingChannelBandwidth
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOOPERATINGCHANNELBANDWIDTH_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOEXTENSIONCHANNEL_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOEXTENSIONCHANNEL_FLAG; /* clear clabWIFIRadioExtensionChannel */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioExtensionChannel.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioExtensionChannel commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioExtensionChannel
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOEXTENSIONCHANNEL_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOGUARDINTERVAL_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOGUARDINTERVAL_FLAG; /* clear clabWIFIRadioGuardInterval */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioGuardInterval.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioGuardInterval commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioGuardInterval
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOGUARDINTERVAL_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOMCS_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOMCS_FLAG; /* clear clabWIFIRadioMCS */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioMCS.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioMCS commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioMCS
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOMCS_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOTRANSMITPOWERSUPPORTED_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOTRANSMITPOWERSUPPORTED_FLAG; /* clear clabWIFIRadioTransmitPowerSupported */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioTransmitPowerSupported.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioTransmitPowerSupported commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioTransmitPowerSupported
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOTRANSMITPOWERSUPPORTED_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOTRANSMITPOWER_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOTRANSMITPOWER_FLAG; /* clear clabWIFIRadioTransmitPower */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioTransmitPower.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioTransmitPower commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioTransmitPower
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOTRANSMITPOWER_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOIEEE80211HSUPPORTED_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOIEEE80211HSUPPORTED_FLAG; /* clear clabWIFIRadioIEEE80211hSupported */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioIEEE80211hSupported.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioIEEE80211hSupported commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioIEEE80211hSupported
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOIEEE80211HSUPPORTED_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOIEEE80211HENABLED_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOIEEE80211HENABLED_FLAG; /* clear clabWIFIRadioIEEE80211hEnabled */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioIEEE80211hEnabled.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioIEEE80211hEnabled commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioIEEE80211hEnabled
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOIEEE80211HENABLED_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOREGULATORYDOMAIN_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOREGULATORYDOMAIN_FLAG; /* clear clabWIFIRadioRegulatoryDomain */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioRegulatoryDomain.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioRegulatoryDomain commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioRegulatoryDomain
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOREGULATORYDOMAIN_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIONONCONTIGUOUSCHANNEL_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIONONCONTIGUOUSCHANNEL_FLAG; /* clear clabWIFIRadioNoncontiguousChannel */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioNoncontiguousChannel.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioNoncontiguousChannel commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioNoncontiguousChannel
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIONONCONTIGUOUSCHANNEL_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDINUSE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDINUSE_FLAG; /* clear clabWIFIRadioCarrierSenseThresholdInUse */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioCarrierSenseThresholdInUse.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioCarrierSenseThresholdInUse commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioCarrierSenseThresholdInUse
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDINUSE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDRANGE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDRANGE_FLAG; /* clear clabWIFIRadioCarrierSenseThresholdRange */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioCarrierSenseThresholdRange.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioCarrierSenseThresholdRange commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioCarrierSenseThresholdRange
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOCARRIERSENSETHRESHOLDRANGE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOSTATSCHANUTILIZATION_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOSTATSCHANUTILIZATION_FLAG; /* clear clabWIFIRadioStatsChanUtilization */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioStatsChanUtilization.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioStatsChanUtilization commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioStatsChanUtilization
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOSTATSCHANUTILIZATION_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIORTSCTSEXCHANGE_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIORTSCTSEXCHANGE_FLAG; /* clear clabWIFIRadioRtsCtsExchange */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioRtsCtsExchange.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioRtsCtsExchange commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioRtsCtsExchange
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIORTSCTSEXCHANGE_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOFRAMEAGGREGATIONLEVEL_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOFRAMEAGGREGATIONLEVEL_FLAG; /* clear clabWIFIRadioFrameAggregationLevel */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioFrameAggregationLevel.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioFrameAggregationLevel commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioFrameAggregationLevel
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOFRAMEAGGREGATIONLEVEL_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOTHROUGHPUT_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOTHROUGHPUT_FLAG; /* clear clabWIFIRadioThroughput */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioThroughput.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioThroughput commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioThroughput
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOTHROUGHPUT_FLAG;
       }
    }

    if (save_flags & COLUMN_CLABWIFIRADIOPKTERRORRATESTA_FLAG) {
       save_flags &= ~COLUMN_CLABWIFIRADIOPKTERRORRATESTA_FLAG; /* clear clabWIFIRadioPktErrorRateSTA */
       /*
        * TODO:482:o: |-> commit column clabWIFIRadioPktErrorRateSTA.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"clabWIFIRadioTable column clabWIFIRadioPktErrorRateSTA commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo clabWIFIRadioPktErrorRateSTA
             */
            rowreq_ctx->column_set_flags |= COLUMN_CLABWIFIRADIOPKTERRORRATESTA_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* clabWIFIRadioTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * clabWIFIRadioTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param clabWIFIRadioTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
clabWIFIRadioTable_undo_commit( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo clabWIFIRadioTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* clabWIFIRadioTable_undo_commit */

/*
 * TODO:440:M: Implement clabWIFIRadioTable node value checks.
 * TODO:450:M: Implement clabWIFIRadioTable undo functions.
 * TODO:460:M: Implement clabWIFIRadioTable set functions.
 * TODO:480:M: Implement clabWIFIRadioTable commit functions.
 */
/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioEnable
 * clabWIFIRadioEnable is subid 2 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.2
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Enable
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioEnable_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioEnable_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioEnable value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioEnable value not illegal */
} /* clabWIFIRadioEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioEnable_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioEnable undo.
     */
    /*
     * copy clabWIFIRadioEnable data
     * set rowreq_ctx->undo->clabWIFIRadioEnable from rowreq_ctx->data.clabWIFIRadioEnable
     */
    rowreq_ctx->undo->clabWIFIRadioEnable = rowreq_ctx->data.clabWIFIRadioEnable;


    return MFD_SUCCESS;
} /* clabWIFIRadioEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioEnable_val
 *        A long containing the new value.
 */
int
clabWIFIRadioEnable_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioEnable_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioEnable value.
     * set clabWIFIRadioEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioEnable = clabWIFIRadioEnable_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioEnable_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioEnable undo.
     */
    /*
     * copy clabWIFIRadioEnable data
     * set rowreq_ctx->data.clabWIFIRadioEnable from rowreq_ctx->undo->clabWIFIRadioEnable
     */
    rowreq_ctx->data.clabWIFIRadioEnable = rowreq_ctx->undo->clabWIFIRadioEnable;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioEnable_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioStatus
 * clabWIFIRadioStatus is subid 3 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.3
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 4/8. Values:  up(1), down(2), unknown(4), dormant(5), notPresent(6), lowerLayerDown(7), error(8)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  up(1), down(2), unknown(4), dormant(5), notPresent(6), lowerLayerDown(7), error(8)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioStatus_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioStatus_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioStatus value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioStatus value not illegal */
} /* clabWIFIRadioStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioStatus_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioStatus undo.
     */
    /*
     * copy clabWIFIRadioStatus data
     * set rowreq_ctx->undo->clabWIFIRadioStatus from rowreq_ctx->data.clabWIFIRadioStatus
     */
    rowreq_ctx->undo->clabWIFIRadioStatus = rowreq_ctx->data.clabWIFIRadioStatus;


    return MFD_SUCCESS;
} /* clabWIFIRadioStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioStatus_val
 *        A long containing the new value.
 */
int
clabWIFIRadioStatus_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioStatus_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioStatus value.
     * set clabWIFIRadioStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioStatus = clabWIFIRadioStatus_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioStatus_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioStatus undo.
     */
    /*
     * copy clabWIFIRadioStatus data
     * set rowreq_ctx->data.clabWIFIRadioStatus from rowreq_ctx->undo->clabWIFIRadioStatus
     */
    rowreq_ctx->data.clabWIFIRadioStatus = rowreq_ctx->undo->clabWIFIRadioStatus;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioStatus_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioAlias
 * clabWIFIRadioAlias is subid 4 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.4
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Alias.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioAlias_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioAlias_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioAlias_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioAlias).
 *    The length is in (one of) the range set(s):  0 - 64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioAlias_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioAlias_val_ptr,  size_t clabWIFIRadioAlias_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAlias_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioAlias_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioAlias value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioAlias value not illegal */
} /* clabWIFIRadioAlias_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioAlias_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAlias_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioAlias undo.
     */
    /*
     * copy clabWIFIRadioAlias and clabWIFIRadioAlias_len data
     * set rowreq_ctx->undo->clabWIFIRadioAlias from rowreq_ctx->data.clabWIFIRadioAlias
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioAlias, rowreq_ctx->data.clabWIFIRadioAlias,
            (rowreq_ctx->data.clabWIFIRadioAlias_len * sizeof(rowreq_ctx->undo->clabWIFIRadioAlias[0])));
    rowreq_ctx->undo->clabWIFIRadioAlias_len = rowreq_ctx->data.clabWIFIRadioAlias_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioAlias_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioAlias_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioAlias_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioAlias_val_ptr
 */
int
clabWIFIRadioAlias_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioAlias_val_ptr,  size_t clabWIFIRadioAlias_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAlias_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioAlias_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioAlias value.
     * set clabWIFIRadioAlias value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioAlias, clabWIFIRadioAlias_val_ptr, clabWIFIRadioAlias_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioAlias_len = clabWIFIRadioAlias_val_ptr_len / sizeof(clabWIFIRadioAlias_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioAlias_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioAlias_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAlias_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioAlias undo.
     */
    /*
     * copy clabWIFIRadioAlias and clabWIFIRadioAlias_len data
     * set rowreq_ctx->data.clabWIFIRadioAlias from rowreq_ctx->undo->clabWIFIRadioAlias
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioAlias, rowreq_ctx->undo->clabWIFIRadioAlias,
            (rowreq_ctx->undo->clabWIFIRadioAlias_len * sizeof(rowreq_ctx->data.clabWIFIRadioAlias[0])));
    rowreq_ctx->data.clabWIFIRadioAlias_len = rowreq_ctx->undo->clabWIFIRadioAlias_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioAlias_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioName
 * clabWIFIRadioName is subid 5 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.5
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Name.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioName_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioName_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioName_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioName).
 *    The length is in (one of) the range set(s):  0 - 64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioName_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioName_val_ptr,  size_t clabWIFIRadioName_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioName_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioName_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioName value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioName value not illegal */
} /* clabWIFIRadioName_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioName_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioName_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioName undo.
     */
    /*
     * copy clabWIFIRadioName and clabWIFIRadioName_len data
     * set rowreq_ctx->undo->clabWIFIRadioName from rowreq_ctx->data.clabWIFIRadioName
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioName, rowreq_ctx->data.clabWIFIRadioName,
            (rowreq_ctx->data.clabWIFIRadioName_len * sizeof(rowreq_ctx->undo->clabWIFIRadioName[0])));
    rowreq_ctx->undo->clabWIFIRadioName_len = rowreq_ctx->data.clabWIFIRadioName_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioName_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioName_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioName_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioName_val_ptr
 */
int
clabWIFIRadioName_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioName_val_ptr,  size_t clabWIFIRadioName_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioName_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioName_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioName value.
     * set clabWIFIRadioName value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioName, clabWIFIRadioName_val_ptr, clabWIFIRadioName_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioName_len = clabWIFIRadioName_val_ptr_len / sizeof(clabWIFIRadioName_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioName_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioName_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioName_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioName undo.
     */
    /*
     * copy clabWIFIRadioName and clabWIFIRadioName_len data
     * set rowreq_ctx->data.clabWIFIRadioName from rowreq_ctx->undo->clabWIFIRadioName
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioName, rowreq_ctx->undo->clabWIFIRadioName,
            (rowreq_ctx->undo->clabWIFIRadioName_len * sizeof(rowreq_ctx->data.clabWIFIRadioName[0])));
    rowreq_ctx->data.clabWIFIRadioName_len = rowreq_ctx->undo->clabWIFIRadioName_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioName_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioLastChange
 * clabWIFIRadioLastChange is subid 6 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.6
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.LastChange.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioLastChange_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioLastChange_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioLastChange_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLastChange_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioLastChange value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioLastChange value not illegal */
} /* clabWIFIRadioLastChange_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioLastChange_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLastChange_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioLastChange undo.
     */
    /*
     * copy clabWIFIRadioLastChange data
     * set rowreq_ctx->undo->clabWIFIRadioLastChange from rowreq_ctx->data.clabWIFIRadioLastChange
     */
    rowreq_ctx->undo->clabWIFIRadioLastChange = rowreq_ctx->data.clabWIFIRadioLastChange;


    return MFD_SUCCESS;
} /* clabWIFIRadioLastChange_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioLastChange_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioLastChange_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioLastChange_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLastChange_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioLastChange value.
     * set clabWIFIRadioLastChange value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioLastChange = clabWIFIRadioLastChange_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioLastChange_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioLastChange_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLastChange_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioLastChange undo.
     */
    /*
     * copy clabWIFIRadioLastChange data
     * set rowreq_ctx->data.clabWIFIRadioLastChange from rowreq_ctx->undo->clabWIFIRadioLastChange
     */
    rowreq_ctx->data.clabWIFIRadioLastChange = rowreq_ctx->undo->clabWIFIRadioLastChange;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioLastChange_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioLowerLayers
 * clabWIFIRadioLowerLayers is subid 7 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.7
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.LowerLayers.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 1024;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 1024)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioLowerLayers_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioLowerLayers_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioLowerLayers_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioLowerLayers).
 *    The length is in (one of) the range set(s):  0 - 1024
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioLowerLayers_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioLowerLayers_val_ptr,  size_t clabWIFIRadioLowerLayers_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLowerLayers_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioLowerLayers_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioLowerLayers value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioLowerLayers value not illegal */
} /* clabWIFIRadioLowerLayers_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioLowerLayers_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLowerLayers_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioLowerLayers undo.
     */
    /*
     * copy clabWIFIRadioLowerLayers and clabWIFIRadioLowerLayers_len data
     * set rowreq_ctx->undo->clabWIFIRadioLowerLayers from rowreq_ctx->data.clabWIFIRadioLowerLayers
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioLowerLayers, rowreq_ctx->data.clabWIFIRadioLowerLayers,
            (rowreq_ctx->data.clabWIFIRadioLowerLayers_len * sizeof(rowreq_ctx->undo->clabWIFIRadioLowerLayers[0])));
    rowreq_ctx->undo->clabWIFIRadioLowerLayers_len = rowreq_ctx->data.clabWIFIRadioLowerLayers_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioLowerLayers_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioLowerLayers_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioLowerLayers_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioLowerLayers_val_ptr
 */
int
clabWIFIRadioLowerLayers_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioLowerLayers_val_ptr,  size_t clabWIFIRadioLowerLayers_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLowerLayers_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioLowerLayers_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioLowerLayers value.
     * set clabWIFIRadioLowerLayers value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioLowerLayers, clabWIFIRadioLowerLayers_val_ptr, clabWIFIRadioLowerLayers_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioLowerLayers_len = clabWIFIRadioLowerLayers_val_ptr_len / sizeof(clabWIFIRadioLowerLayers_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioLowerLayers_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioLowerLayers_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioLowerLayers_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioLowerLayers undo.
     */
    /*
     * copy clabWIFIRadioLowerLayers and clabWIFIRadioLowerLayers_len data
     * set rowreq_ctx->data.clabWIFIRadioLowerLayers from rowreq_ctx->undo->clabWIFIRadioLowerLayers
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioLowerLayers, rowreq_ctx->undo->clabWIFIRadioLowerLayers,
            (rowreq_ctx->undo->clabWIFIRadioLowerLayers_len * sizeof(rowreq_ctx->data.clabWIFIRadioLowerLayers[0])));
    rowreq_ctx->data.clabWIFIRadioLowerLayers_len = rowreq_ctx->undo->clabWIFIRadioLowerLayers_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioLowerLayers_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioUpstream
 * clabWIFIRadioUpstream is subid 8 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.8
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Upstream
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioUpstream_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioUpstream_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioUpstream_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioUpstream_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioUpstream value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioUpstream value not illegal */
} /* clabWIFIRadioUpstream_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioUpstream_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioUpstream_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioUpstream undo.
     */
    /*
     * copy clabWIFIRadioUpstream data
     * set rowreq_ctx->undo->clabWIFIRadioUpstream from rowreq_ctx->data.clabWIFIRadioUpstream
     */
    rowreq_ctx->undo->clabWIFIRadioUpstream = rowreq_ctx->data.clabWIFIRadioUpstream;


    return MFD_SUCCESS;
} /* clabWIFIRadioUpstream_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioUpstream_val
 *        A long containing the new value.
 */
int
clabWIFIRadioUpstream_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioUpstream_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioUpstream_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioUpstream value.
     * set clabWIFIRadioUpstream value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioUpstream = clabWIFIRadioUpstream_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioUpstream_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioUpstream_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioUpstream_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioUpstream undo.
     */
    /*
     * copy clabWIFIRadioUpstream data
     * set rowreq_ctx->data.clabWIFIRadioUpstream from rowreq_ctx->undo->clabWIFIRadioUpstream
     */
    rowreq_ctx->data.clabWIFIRadioUpstream = rowreq_ctx->undo->clabWIFIRadioUpstream;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioUpstream_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioMaxBitRate
 * clabWIFIRadioMaxBitRate is subid 9 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.9
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.MaxBitRate.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioMaxBitRate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioMaxBitRate_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioMaxBitRate_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMaxBitRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioMaxBitRate value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioMaxBitRate value not illegal */
} /* clabWIFIRadioMaxBitRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioMaxBitRate_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMaxBitRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioMaxBitRate undo.
     */
    /*
     * copy clabWIFIRadioMaxBitRate data
     * set rowreq_ctx->undo->clabWIFIRadioMaxBitRate from rowreq_ctx->data.clabWIFIRadioMaxBitRate
     */
    rowreq_ctx->undo->clabWIFIRadioMaxBitRate = rowreq_ctx->data.clabWIFIRadioMaxBitRate;


    return MFD_SUCCESS;
} /* clabWIFIRadioMaxBitRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioMaxBitRate_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioMaxBitRate_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioMaxBitRate_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMaxBitRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioMaxBitRate value.
     * set clabWIFIRadioMaxBitRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioMaxBitRate = clabWIFIRadioMaxBitRate_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioMaxBitRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioMaxBitRate_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMaxBitRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioMaxBitRate undo.
     */
    /*
     * copy clabWIFIRadioMaxBitRate data
     * set rowreq_ctx->data.clabWIFIRadioMaxBitRate from rowreq_ctx->undo->clabWIFIRadioMaxBitRate
     */
    rowreq_ctx->data.clabWIFIRadioMaxBitRate = rowreq_ctx->undo->clabWIFIRadioMaxBitRate;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioMaxBitRate_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioSupportedFrequencyBands
 * clabWIFIRadioSupportedFrequencyBands is subid 10 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.10
 * Description:
This object is defined in TR-181 Device.WiFi.RadioSupportedFrequencyBands.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioSupportedFrequencyBands_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioSupportedFrequencyBands_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioSupportedFrequencyBands_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioSupportedFrequencyBands_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioSupportedFrequencyBands_val_ptr,  size_t clabWIFIRadioSupportedFrequencyBands_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedFrequencyBands_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioSupportedFrequencyBands_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioSupportedFrequencyBands value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioSupportedFrequencyBands value not illegal */
} /* clabWIFIRadioSupportedFrequencyBands_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioSupportedFrequencyBands_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedFrequencyBands_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioSupportedFrequencyBands undo.
     */
    /*
     * copy clabWIFIRadioSupportedFrequencyBands and clabWIFIRadioSupportedFrequencyBands_len data
     * set rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands from rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands, rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands,
            (rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands_len * sizeof(rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands[0])));
    rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands_len = rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedFrequencyBands_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioSupportedFrequencyBands_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioSupportedFrequencyBands_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioSupportedFrequencyBands_val_ptr
 */
int
clabWIFIRadioSupportedFrequencyBands_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioSupportedFrequencyBands_val_ptr,  size_t clabWIFIRadioSupportedFrequencyBands_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedFrequencyBands_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioSupportedFrequencyBands_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioSupportedFrequencyBands value.
     * set clabWIFIRadioSupportedFrequencyBands value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands, clabWIFIRadioSupportedFrequencyBands_val_ptr, clabWIFIRadioSupportedFrequencyBands_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands_len = clabWIFIRadioSupportedFrequencyBands_val_ptr_len / sizeof(clabWIFIRadioSupportedFrequencyBands_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedFrequencyBands_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioSupportedFrequencyBands_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedFrequencyBands_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioSupportedFrequencyBands undo.
     */
    /*
     * copy clabWIFIRadioSupportedFrequencyBands and clabWIFIRadioSupportedFrequencyBands_len data
     * set rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands from rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands, rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands,
            (rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands_len * sizeof(rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands[0])));
    rowreq_ctx->data.clabWIFIRadioSupportedFrequencyBands_len = rowreq_ctx->undo->clabWIFIRadioSupportedFrequencyBands_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedFrequencyBands_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioOperatingFrequencyBand
 * clabWIFIRadioOperatingFrequencyBand is subid 11 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.11
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.OperatingFrequencyBand
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  n2dot4Ghz(1), n5Ghz(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioOperatingFrequencyBand_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  n2dot4Ghz(1), n5Ghz(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioOperatingFrequencyBand_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingFrequencyBand_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingFrequencyBand_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioOperatingFrequencyBand value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioOperatingFrequencyBand value not illegal */
} /* clabWIFIRadioOperatingFrequencyBand_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioOperatingFrequencyBand_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingFrequencyBand_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioOperatingFrequencyBand undo.
     */
    /*
     * copy clabWIFIRadioOperatingFrequencyBand data
     * set rowreq_ctx->undo->clabWIFIRadioOperatingFrequencyBand from rowreq_ctx->data.clabWIFIRadioOperatingFrequencyBand
     */
    rowreq_ctx->undo->clabWIFIRadioOperatingFrequencyBand = rowreq_ctx->data.clabWIFIRadioOperatingFrequencyBand;


    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingFrequencyBand_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioOperatingFrequencyBand_val
 *        A long containing the new value.
 */
int
clabWIFIRadioOperatingFrequencyBand_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingFrequencyBand_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingFrequencyBand_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioOperatingFrequencyBand value.
     * set clabWIFIRadioOperatingFrequencyBand value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioOperatingFrequencyBand = clabWIFIRadioOperatingFrequencyBand_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingFrequencyBand_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioOperatingFrequencyBand_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingFrequencyBand_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioOperatingFrequencyBand undo.
     */
    /*
     * copy clabWIFIRadioOperatingFrequencyBand data
     * set rowreq_ctx->data.clabWIFIRadioOperatingFrequencyBand from rowreq_ctx->undo->clabWIFIRadioOperatingFrequencyBand
     */
    rowreq_ctx->data.clabWIFIRadioOperatingFrequencyBand = rowreq_ctx->undo->clabWIFIRadioOperatingFrequencyBand;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingFrequencyBand_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioSupportedStandards
 * clabWIFIRadioSupportedStandards is subid 12 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.12
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.SupportedStandards
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioSupportedStandards_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioSupportedStandards_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioSupportedStandards_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioSupportedStandards).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioSupportedStandards_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioSupportedStandards_val_ptr,  size_t clabWIFIRadioSupportedStandards_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedStandards_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioSupportedStandards_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioSupportedStandards value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioSupportedStandards value not illegal */
} /* clabWIFIRadioSupportedStandards_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioSupportedStandards_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedStandards_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioSupportedStandards undo.
     */
    /*
     * copy clabWIFIRadioSupportedStandards and clabWIFIRadioSupportedStandards_len data
     * set rowreq_ctx->undo->clabWIFIRadioSupportedStandards from rowreq_ctx->data.clabWIFIRadioSupportedStandards
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioSupportedStandards, rowreq_ctx->data.clabWIFIRadioSupportedStandards,
            (rowreq_ctx->data.clabWIFIRadioSupportedStandards_len * sizeof(rowreq_ctx->undo->clabWIFIRadioSupportedStandards[0])));
    rowreq_ctx->undo->clabWIFIRadioSupportedStandards_len = rowreq_ctx->data.clabWIFIRadioSupportedStandards_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedStandards_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioSupportedStandards_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioSupportedStandards_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioSupportedStandards_val_ptr
 */
int
clabWIFIRadioSupportedStandards_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioSupportedStandards_val_ptr,  size_t clabWIFIRadioSupportedStandards_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedStandards_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioSupportedStandards_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioSupportedStandards value.
     * set clabWIFIRadioSupportedStandards value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioSupportedStandards, clabWIFIRadioSupportedStandards_val_ptr, clabWIFIRadioSupportedStandards_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioSupportedStandards_len = clabWIFIRadioSupportedStandards_val_ptr_len / sizeof(clabWIFIRadioSupportedStandards_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedStandards_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioSupportedStandards_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioSupportedStandards_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioSupportedStandards undo.
     */
    /*
     * copy clabWIFIRadioSupportedStandards and clabWIFIRadioSupportedStandards_len data
     * set rowreq_ctx->data.clabWIFIRadioSupportedStandards from rowreq_ctx->undo->clabWIFIRadioSupportedStandards
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioSupportedStandards, rowreq_ctx->undo->clabWIFIRadioSupportedStandards,
            (rowreq_ctx->undo->clabWIFIRadioSupportedStandards_len * sizeof(rowreq_ctx->data.clabWIFIRadioSupportedStandards[0])));
    rowreq_ctx->data.clabWIFIRadioSupportedStandards_len = rowreq_ctx->undo->clabWIFIRadioSupportedStandards_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioSupportedStandards_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioOperatingStandards
 * clabWIFIRadioOperatingStandards is subid 13 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.13
 * Description:
This object is modified from TR-181 Device.WiFi.Radio.{i}.OperatingStandards
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 4/8. Values:  a(1), b(2), g(3), n(5), ac(6)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioOperatingStandards_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  a(1), b(2), g(3), n(5), ac(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioOperatingStandards_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingStandards_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingStandards_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioOperatingStandards value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioOperatingStandards value not illegal */
} /* clabWIFIRadioOperatingStandards_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioOperatingStandards_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingStandards_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioOperatingStandards undo.
     */
    /*
     * copy clabWIFIRadioOperatingStandards data
     * set rowreq_ctx->undo->clabWIFIRadioOperatingStandards from rowreq_ctx->data.clabWIFIRadioOperatingStandards
     */
    rowreq_ctx->undo->clabWIFIRadioOperatingStandards = rowreq_ctx->data.clabWIFIRadioOperatingStandards;


    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingStandards_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioOperatingStandards_val
 *        A long containing the new value.
 */
int
clabWIFIRadioOperatingStandards_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingStandards_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingStandards_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioOperatingStandards value.
     * set clabWIFIRadioOperatingStandards value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioOperatingStandards = clabWIFIRadioOperatingStandards_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingStandards_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioOperatingStandards_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingStandards_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioOperatingStandards undo.
     */
    /*
     * copy clabWIFIRadioOperatingStandards data
     * set rowreq_ctx->data.clabWIFIRadioOperatingStandards from rowreq_ctx->undo->clabWIFIRadioOperatingStandards
     */
    rowreq_ctx->data.clabWIFIRadioOperatingStandards = rowreq_ctx->undo->clabWIFIRadioOperatingStandards;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingStandards_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioPossibleChannels
 * clabWIFIRadioPossibleChannels is subid 14 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.14
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.PossibleChannels
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 1024;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 1024)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioPossibleChannels_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioPossibleChannels_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioPossibleChannels_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioPossibleChannels).
 *    The length is in (one of) the range set(s):  0 - 1024
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioPossibleChannels_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioPossibleChannels_val_ptr,  size_t clabWIFIRadioPossibleChannels_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPossibleChannels_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioPossibleChannels_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioPossibleChannels value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioPossibleChannels value not illegal */
} /* clabWIFIRadioPossibleChannels_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioPossibleChannels_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPossibleChannels_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioPossibleChannels undo.
     */
    /*
     * copy clabWIFIRadioPossibleChannels and clabWIFIRadioPossibleChannels_len data
     * set rowreq_ctx->undo->clabWIFIRadioPossibleChannels from rowreq_ctx->data.clabWIFIRadioPossibleChannels
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioPossibleChannels, rowreq_ctx->data.clabWIFIRadioPossibleChannels,
            (rowreq_ctx->data.clabWIFIRadioPossibleChannels_len * sizeof(rowreq_ctx->undo->clabWIFIRadioPossibleChannels[0])));
    rowreq_ctx->undo->clabWIFIRadioPossibleChannels_len = rowreq_ctx->data.clabWIFIRadioPossibleChannels_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioPossibleChannels_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioPossibleChannels_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioPossibleChannels_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioPossibleChannels_val_ptr
 */
int
clabWIFIRadioPossibleChannels_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioPossibleChannels_val_ptr,  size_t clabWIFIRadioPossibleChannels_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPossibleChannels_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioPossibleChannels_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioPossibleChannels value.
     * set clabWIFIRadioPossibleChannels value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioPossibleChannels, clabWIFIRadioPossibleChannels_val_ptr, clabWIFIRadioPossibleChannels_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioPossibleChannels_len = clabWIFIRadioPossibleChannels_val_ptr_len / sizeof(clabWIFIRadioPossibleChannels_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioPossibleChannels_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioPossibleChannels_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPossibleChannels_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioPossibleChannels undo.
     */
    /*
     * copy clabWIFIRadioPossibleChannels and clabWIFIRadioPossibleChannels_len data
     * set rowreq_ctx->data.clabWIFIRadioPossibleChannels from rowreq_ctx->undo->clabWIFIRadioPossibleChannels
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioPossibleChannels, rowreq_ctx->undo->clabWIFIRadioPossibleChannels,
            (rowreq_ctx->undo->clabWIFIRadioPossibleChannels_len * sizeof(rowreq_ctx->data.clabWIFIRadioPossibleChannels[0])));
    rowreq_ctx->data.clabWIFIRadioPossibleChannels_len = rowreq_ctx->undo->clabWIFIRadioPossibleChannels_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioPossibleChannels_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioChannelsInUse
 * clabWIFIRadioChannelsInUse is subid 15 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.15
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.ChannelsInUse
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 1024;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 1024)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioChannelsInUse_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioChannelsInUse_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioChannelsInUse_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioChannelsInUse).
 *    The length is in (one of) the range set(s):  0 - 1024
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioChannelsInUse_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioChannelsInUse_val_ptr,  size_t clabWIFIRadioChannelsInUse_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannelsInUse_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioChannelsInUse_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioChannelsInUse value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioChannelsInUse value not illegal */
} /* clabWIFIRadioChannelsInUse_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioChannelsInUse_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannelsInUse_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioChannelsInUse undo.
     */
    /*
     * copy clabWIFIRadioChannelsInUse and clabWIFIRadioChannelsInUse_len data
     * set rowreq_ctx->undo->clabWIFIRadioChannelsInUse from rowreq_ctx->data.clabWIFIRadioChannelsInUse
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioChannelsInUse, rowreq_ctx->data.clabWIFIRadioChannelsInUse,
            (rowreq_ctx->data.clabWIFIRadioChannelsInUse_len * sizeof(rowreq_ctx->undo->clabWIFIRadioChannelsInUse[0])));
    rowreq_ctx->undo->clabWIFIRadioChannelsInUse_len = rowreq_ctx->data.clabWIFIRadioChannelsInUse_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioChannelsInUse_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioChannelsInUse_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioChannelsInUse_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioChannelsInUse_val_ptr
 */
int
clabWIFIRadioChannelsInUse_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioChannelsInUse_val_ptr,  size_t clabWIFIRadioChannelsInUse_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannelsInUse_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioChannelsInUse_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioChannelsInUse value.
     * set clabWIFIRadioChannelsInUse value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioChannelsInUse, clabWIFIRadioChannelsInUse_val_ptr, clabWIFIRadioChannelsInUse_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioChannelsInUse_len = clabWIFIRadioChannelsInUse_val_ptr_len / sizeof(clabWIFIRadioChannelsInUse_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioChannelsInUse_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioChannelsInUse_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannelsInUse_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioChannelsInUse undo.
     */
    /*
     * copy clabWIFIRadioChannelsInUse and clabWIFIRadioChannelsInUse_len data
     * set rowreq_ctx->data.clabWIFIRadioChannelsInUse from rowreq_ctx->undo->clabWIFIRadioChannelsInUse
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioChannelsInUse, rowreq_ctx->undo->clabWIFIRadioChannelsInUse,
            (rowreq_ctx->undo->clabWIFIRadioChannelsInUse_len * sizeof(rowreq_ctx->data.clabWIFIRadioChannelsInUse[0])));
    rowreq_ctx->data.clabWIFIRadioChannelsInUse_len = rowreq_ctx->undo->clabWIFIRadioChannelsInUse_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioChannelsInUse_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioChannel
 * clabWIFIRadioChannel is subid 16 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.16
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.Channel.
         For 80MHz, 160MHz and 80+80MHz RF channels of 802.11ac, this
         object indicates the Primary Channel of the RF channel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioChannel_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *    The value is in (one of) the range set(s):  1 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioChannel_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioChannel_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannel_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioChannel value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioChannel value not illegal */
} /* clabWIFIRadioChannel_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioChannel_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannel_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioChannel undo.
     */
    /*
     * copy clabWIFIRadioChannel data
     * set rowreq_ctx->undo->clabWIFIRadioChannel from rowreq_ctx->data.clabWIFIRadioChannel
     */
    rowreq_ctx->undo->clabWIFIRadioChannel = rowreq_ctx->data.clabWIFIRadioChannel;


    return MFD_SUCCESS;
} /* clabWIFIRadioChannel_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioChannel_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioChannel_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioChannel_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannel_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioChannel value.
     * set clabWIFIRadioChannel value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioChannel = clabWIFIRadioChannel_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioChannel_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioChannel_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioChannel_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioChannel undo.
     */
    /*
     * copy clabWIFIRadioChannel data
     * set rowreq_ctx->data.clabWIFIRadioChannel from rowreq_ctx->undo->clabWIFIRadioChannel
     */
    rowreq_ctx->data.clabWIFIRadioChannel = rowreq_ctx->undo->clabWIFIRadioChannel;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioChannel_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioAutoChannelSupported
 * clabWIFIRadioAutoChannelSupported is subid 17 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.17
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.AutoChannelSupported
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioAutoChannelSupported_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioAutoChannelSupported_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelSupported_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelSupported_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioAutoChannelSupported value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioAutoChannelSupported value not illegal */
} /* clabWIFIRadioAutoChannelSupported_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioAutoChannelSupported_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelSupported_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioAutoChannelSupported undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelSupported data
     * set rowreq_ctx->undo->clabWIFIRadioAutoChannelSupported from rowreq_ctx->data.clabWIFIRadioAutoChannelSupported
     */
    rowreq_ctx->undo->clabWIFIRadioAutoChannelSupported = rowreq_ctx->data.clabWIFIRadioAutoChannelSupported;


    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelSupported_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioAutoChannelSupported_val
 *        A long containing the new value.
 */
int
clabWIFIRadioAutoChannelSupported_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelSupported_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelSupported_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioAutoChannelSupported value.
     * set clabWIFIRadioAutoChannelSupported value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelSupported = clabWIFIRadioAutoChannelSupported_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelSupported_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioAutoChannelSupported_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelSupported_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioAutoChannelSupported undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelSupported data
     * set rowreq_ctx->data.clabWIFIRadioAutoChannelSupported from rowreq_ctx->undo->clabWIFIRadioAutoChannelSupported
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelSupported = rowreq_ctx->undo->clabWIFIRadioAutoChannelSupported;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelSupported_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioAutoChannelEnable
 * clabWIFIRadioAutoChannelEnable is subid 18 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.18
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.AutoChannelEnable
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioAutoChannelEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioAutoChannelEnable_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelEnable_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioAutoChannelEnable value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioAutoChannelEnable value not illegal */
} /* clabWIFIRadioAutoChannelEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioAutoChannelEnable_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioAutoChannelEnable undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelEnable data
     * set rowreq_ctx->undo->clabWIFIRadioAutoChannelEnable from rowreq_ctx->data.clabWIFIRadioAutoChannelEnable
     */
    rowreq_ctx->undo->clabWIFIRadioAutoChannelEnable = rowreq_ctx->data.clabWIFIRadioAutoChannelEnable;


    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioAutoChannelEnable_val
 *        A long containing the new value.
 */
int
clabWIFIRadioAutoChannelEnable_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelEnable_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioAutoChannelEnable value.
     * set clabWIFIRadioAutoChannelEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelEnable = clabWIFIRadioAutoChannelEnable_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioAutoChannelEnable_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioAutoChannelEnable undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelEnable data
     * set rowreq_ctx->data.clabWIFIRadioAutoChannelEnable from rowreq_ctx->undo->clabWIFIRadioAutoChannelEnable
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelEnable = rowreq_ctx->undo->clabWIFIRadioAutoChannelEnable;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelEnable_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioAutoChannelRefreshPeriod
 * clabWIFIRadioAutoChannelRefreshPeriod is subid 19 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.19
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.AutoChannelRefreshPeriod
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioAutoChannelRefreshPeriod_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioAutoChannelRefreshPeriod_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelRefreshPeriod_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelRefreshPeriod_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioAutoChannelRefreshPeriod value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioAutoChannelRefreshPeriod value not illegal */
} /* clabWIFIRadioAutoChannelRefreshPeriod_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioAutoChannelRefreshPeriod_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelRefreshPeriod_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioAutoChannelRefreshPeriod undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelRefreshPeriod data
     * set rowreq_ctx->undo->clabWIFIRadioAutoChannelRefreshPeriod from rowreq_ctx->data.clabWIFIRadioAutoChannelRefreshPeriod
     */
    rowreq_ctx->undo->clabWIFIRadioAutoChannelRefreshPeriod = rowreq_ctx->data.clabWIFIRadioAutoChannelRefreshPeriod;


    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelRefreshPeriod_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioAutoChannelRefreshPeriod_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioAutoChannelRefreshPeriod_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioAutoChannelRefreshPeriod_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelRefreshPeriod_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioAutoChannelRefreshPeriod value.
     * set clabWIFIRadioAutoChannelRefreshPeriod value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelRefreshPeriod = clabWIFIRadioAutoChannelRefreshPeriod_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelRefreshPeriod_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioAutoChannelRefreshPeriod_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioAutoChannelRefreshPeriod_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioAutoChannelRefreshPeriod undo.
     */
    /*
     * copy clabWIFIRadioAutoChannelRefreshPeriod data
     * set rowreq_ctx->data.clabWIFIRadioAutoChannelRefreshPeriod from rowreq_ctx->undo->clabWIFIRadioAutoChannelRefreshPeriod
     */
    rowreq_ctx->data.clabWIFIRadioAutoChannelRefreshPeriod = rowreq_ctx->undo->clabWIFIRadioAutoChannelRefreshPeriod;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioAutoChannelRefreshPeriod_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioOperatingChannelBandwidth
 * clabWIFIRadioOperatingChannelBandwidth is subid 20 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.20
 * Description:
This object is modified from TR-181 Device.WiFi.Radio.{i}.OperatingChannelBandwidth
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: auto
 *
 * Enum range: 3/8. Values:  n20MHz(1), n40MHz(2), ac80MHz(3), ac160MHz(4), ac80plus80MHz(5), auto(6)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioOperatingChannelBandwidth_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  n20MHz(1), n40MHz(2), ac80MHz(3), ac160MHz(4), ac80plus80MHz(5), auto(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioOperatingChannelBandwidth_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingChannelBandwidth_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingChannelBandwidth_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioOperatingChannelBandwidth value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioOperatingChannelBandwidth value not illegal */
} /* clabWIFIRadioOperatingChannelBandwidth_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioOperatingChannelBandwidth_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingChannelBandwidth_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioOperatingChannelBandwidth undo.
     */
    /*
     * copy clabWIFIRadioOperatingChannelBandwidth data
     * set rowreq_ctx->undo->clabWIFIRadioOperatingChannelBandwidth from rowreq_ctx->data.clabWIFIRadioOperatingChannelBandwidth
     */
    rowreq_ctx->undo->clabWIFIRadioOperatingChannelBandwidth = rowreq_ctx->data.clabWIFIRadioOperatingChannelBandwidth;


    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingChannelBandwidth_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioOperatingChannelBandwidth_val
 *        A long containing the new value.
 */
int
clabWIFIRadioOperatingChannelBandwidth_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioOperatingChannelBandwidth_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingChannelBandwidth_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioOperatingChannelBandwidth value.
     * set clabWIFIRadioOperatingChannelBandwidth value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioOperatingChannelBandwidth = clabWIFIRadioOperatingChannelBandwidth_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingChannelBandwidth_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioOperatingChannelBandwidth_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioOperatingChannelBandwidth_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioOperatingChannelBandwidth undo.
     */
    /*
     * copy clabWIFIRadioOperatingChannelBandwidth data
     * set rowreq_ctx->data.clabWIFIRadioOperatingChannelBandwidth from rowreq_ctx->undo->clabWIFIRadioOperatingChannelBandwidth
     */
    rowreq_ctx->data.clabWIFIRadioOperatingChannelBandwidth = rowreq_ctx->undo->clabWIFIRadioOperatingChannelBandwidth;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioOperatingChannelBandwidth_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioExtensionChannel
 * clabWIFIRadioExtensionChannel is subid 21 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.21
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.ExtensionChannel
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: auto
 *
 * Enum range: 2/8. Values:  aboveControlChannel(1), belowControlChannel(2), auto(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioExtensionChannel_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  aboveControlChannel(1), belowControlChannel(2), auto(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioExtensionChannel_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioExtensionChannel_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioExtensionChannel_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioExtensionChannel value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioExtensionChannel value not illegal */
} /* clabWIFIRadioExtensionChannel_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioExtensionChannel_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioExtensionChannel_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioExtensionChannel undo.
     */
    /*
     * copy clabWIFIRadioExtensionChannel data
     * set rowreq_ctx->undo->clabWIFIRadioExtensionChannel from rowreq_ctx->data.clabWIFIRadioExtensionChannel
     */
    rowreq_ctx->undo->clabWIFIRadioExtensionChannel = rowreq_ctx->data.clabWIFIRadioExtensionChannel;


    return MFD_SUCCESS;
} /* clabWIFIRadioExtensionChannel_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioExtensionChannel_val
 *        A long containing the new value.
 */
int
clabWIFIRadioExtensionChannel_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioExtensionChannel_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioExtensionChannel_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioExtensionChannel value.
     * set clabWIFIRadioExtensionChannel value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioExtensionChannel = clabWIFIRadioExtensionChannel_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioExtensionChannel_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioExtensionChannel_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioExtensionChannel_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioExtensionChannel undo.
     */
    /*
     * copy clabWIFIRadioExtensionChannel data
     * set rowreq_ctx->data.clabWIFIRadioExtensionChannel from rowreq_ctx->undo->clabWIFIRadioExtensionChannel
     */
    rowreq_ctx->data.clabWIFIRadioExtensionChannel = rowreq_ctx->undo->clabWIFIRadioExtensionChannel;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioExtensionChannel_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioGuardInterval
 * clabWIFIRadioGuardInterval is subid 22 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.22
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.RadioGuardInterval
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: auto
 *
 * Enum range: 2/8. Values:  n400nsec(1), n800nsec(2), auto(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioGuardInterval_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  n400nsec(1), n800nsec(2), auto(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioGuardInterval_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioGuardInterval_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioGuardInterval_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioGuardInterval value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioGuardInterval value not illegal */
} /* clabWIFIRadioGuardInterval_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioGuardInterval_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioGuardInterval_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioGuardInterval undo.
     */
    /*
     * copy clabWIFIRadioGuardInterval data
     * set rowreq_ctx->undo->clabWIFIRadioGuardInterval from rowreq_ctx->data.clabWIFIRadioGuardInterval
     */
    rowreq_ctx->undo->clabWIFIRadioGuardInterval = rowreq_ctx->data.clabWIFIRadioGuardInterval;


    return MFD_SUCCESS;
} /* clabWIFIRadioGuardInterval_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioGuardInterval_val
 *        A long containing the new value.
 */
int
clabWIFIRadioGuardInterval_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioGuardInterval_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioGuardInterval_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioGuardInterval value.
     * set clabWIFIRadioGuardInterval value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioGuardInterval = clabWIFIRadioGuardInterval_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioGuardInterval_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioGuardInterval_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioGuardInterval_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioGuardInterval undo.
     */
    /*
     * copy clabWIFIRadioGuardInterval data
     * set rowreq_ctx->data.clabWIFIRadioGuardInterval from rowreq_ctx->undo->clabWIFIRadioGuardInterval
     */
    rowreq_ctx->data.clabWIFIRadioGuardInterval = rowreq_ctx->undo->clabWIFIRadioGuardInterval;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioGuardInterval_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioMCS
 * clabWIFIRadioMCS is subid 23 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.23
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.RadioMCS 
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  -1 - 31;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioMCS_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  -1 - 31
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioMCS_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioMCS_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMCS_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioMCS value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioMCS value not illegal */
} /* clabWIFIRadioMCS_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioMCS_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMCS_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioMCS undo.
     */
    /*
     * copy clabWIFIRadioMCS data
     * set rowreq_ctx->undo->clabWIFIRadioMCS from rowreq_ctx->data.clabWIFIRadioMCS
     */
    rowreq_ctx->undo->clabWIFIRadioMCS = rowreq_ctx->data.clabWIFIRadioMCS;


    return MFD_SUCCESS;
} /* clabWIFIRadioMCS_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioMCS_val
 *        A long containing the new value.
 */
int
clabWIFIRadioMCS_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioMCS_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMCS_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioMCS value.
     * set clabWIFIRadioMCS value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioMCS = clabWIFIRadioMCS_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioMCS_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioMCS_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioMCS_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioMCS undo.
     */
    /*
     * copy clabWIFIRadioMCS data
     * set rowreq_ctx->data.clabWIFIRadioMCS from rowreq_ctx->undo->clabWIFIRadioMCS
     */
    rowreq_ctx->data.clabWIFIRadioMCS = rowreq_ctx->undo->clabWIFIRadioMCS;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioMCS_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioTransmitPowerSupported
 * clabWIFIRadioTransmitPowerSupported is subid 24 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.24
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.TransmitPowerSupported
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioTransmitPowerSupported_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioTransmitPowerSupported_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioTransmitPowerSupported_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported).
 *    The length is in (one of) the range set(s):  0 - 64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioTransmitPowerSupported_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioTransmitPowerSupported_val_ptr,  size_t clabWIFIRadioTransmitPowerSupported_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPowerSupported_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioTransmitPowerSupported_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioTransmitPowerSupported value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioTransmitPowerSupported value not illegal */
} /* clabWIFIRadioTransmitPowerSupported_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioTransmitPowerSupported_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPowerSupported_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioTransmitPowerSupported undo.
     */
    /*
     * copy clabWIFIRadioTransmitPowerSupported and clabWIFIRadioTransmitPowerSupported_len data
     * set rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported from rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported, rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported,
            (rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported_len * sizeof(rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported[0])));
    rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported_len = rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPowerSupported_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioTransmitPowerSupported_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioTransmitPowerSupported_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioTransmitPowerSupported_val_ptr
 */
int
clabWIFIRadioTransmitPowerSupported_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioTransmitPowerSupported_val_ptr,  size_t clabWIFIRadioTransmitPowerSupported_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPowerSupported_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioTransmitPowerSupported_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioTransmitPowerSupported value.
     * set clabWIFIRadioTransmitPowerSupported value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported, clabWIFIRadioTransmitPowerSupported_val_ptr, clabWIFIRadioTransmitPowerSupported_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported_len = clabWIFIRadioTransmitPowerSupported_val_ptr_len / sizeof(clabWIFIRadioTransmitPowerSupported_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPowerSupported_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioTransmitPowerSupported_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPowerSupported_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioTransmitPowerSupported undo.
     */
    /*
     * copy clabWIFIRadioTransmitPowerSupported and clabWIFIRadioTransmitPowerSupported_len data
     * set rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported from rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported, rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported,
            (rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported_len * sizeof(rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported[0])));
    rowreq_ctx->data.clabWIFIRadioTransmitPowerSupported_len = rowreq_ctx->undo->clabWIFIRadioTransmitPowerSupported_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPowerSupported_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioTransmitPower
 * clabWIFIRadioTransmitPower is subid 25 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.25
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.TransmitPower
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 100;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioTransmitPower_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *    The value is in (one of) the range set(s):  1 - 100
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioTransmitPower_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioTransmitPower_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPower_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioTransmitPower value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioTransmitPower value not illegal */
} /* clabWIFIRadioTransmitPower_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioTransmitPower_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPower_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioTransmitPower undo.
     */
    /*
     * copy clabWIFIRadioTransmitPower data
     * set rowreq_ctx->undo->clabWIFIRadioTransmitPower from rowreq_ctx->data.clabWIFIRadioTransmitPower
     */
    rowreq_ctx->undo->clabWIFIRadioTransmitPower = rowreq_ctx->data.clabWIFIRadioTransmitPower;


    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPower_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioTransmitPower_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioTransmitPower_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioTransmitPower_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPower_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioTransmitPower value.
     * set clabWIFIRadioTransmitPower value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioTransmitPower = clabWIFIRadioTransmitPower_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPower_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioTransmitPower_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioTransmitPower_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioTransmitPower undo.
     */
    /*
     * copy clabWIFIRadioTransmitPower data
     * set rowreq_ctx->data.clabWIFIRadioTransmitPower from rowreq_ctx->undo->clabWIFIRadioTransmitPower
     */
    rowreq_ctx->data.clabWIFIRadioTransmitPower = rowreq_ctx->undo->clabWIFIRadioTransmitPower;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioTransmitPower_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioIEEE80211hSupported
 * clabWIFIRadioIEEE80211hSupported is subid 26 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.26
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.IEEE80211hSupported
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioIEEE80211hSupported_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioIEEE80211hSupported_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioIEEE80211hSupported_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hSupported_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioIEEE80211hSupported value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioIEEE80211hSupported value not illegal */
} /* clabWIFIRadioIEEE80211hSupported_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioIEEE80211hSupported_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hSupported_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioIEEE80211hSupported undo.
     */
    /*
     * copy clabWIFIRadioIEEE80211hSupported data
     * set rowreq_ctx->undo->clabWIFIRadioIEEE80211hSupported from rowreq_ctx->data.clabWIFIRadioIEEE80211hSupported
     */
    rowreq_ctx->undo->clabWIFIRadioIEEE80211hSupported = rowreq_ctx->data.clabWIFIRadioIEEE80211hSupported;


    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hSupported_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioIEEE80211hSupported_val
 *        A long containing the new value.
 */
int
clabWIFIRadioIEEE80211hSupported_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioIEEE80211hSupported_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hSupported_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioIEEE80211hSupported value.
     * set clabWIFIRadioIEEE80211hSupported value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioIEEE80211hSupported = clabWIFIRadioIEEE80211hSupported_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hSupported_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioIEEE80211hSupported_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hSupported_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioIEEE80211hSupported undo.
     */
    /*
     * copy clabWIFIRadioIEEE80211hSupported data
     * set rowreq_ctx->data.clabWIFIRadioIEEE80211hSupported from rowreq_ctx->undo->clabWIFIRadioIEEE80211hSupported
     */
    rowreq_ctx->data.clabWIFIRadioIEEE80211hSupported = rowreq_ctx->undo->clabWIFIRadioIEEE80211hSupported;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hSupported_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioIEEE80211hEnabled
 * clabWIFIRadioIEEE80211hEnabled is subid 27 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.27
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.IEEE80211hEnabled
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioIEEE80211hEnabled_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioIEEE80211hEnabled_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioIEEE80211hEnabled_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hEnabled_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioIEEE80211hEnabled value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioIEEE80211hEnabled value not illegal */
} /* clabWIFIRadioIEEE80211hEnabled_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioIEEE80211hEnabled_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hEnabled_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioIEEE80211hEnabled undo.
     */
    /*
     * copy clabWIFIRadioIEEE80211hEnabled data
     * set rowreq_ctx->undo->clabWIFIRadioIEEE80211hEnabled from rowreq_ctx->data.clabWIFIRadioIEEE80211hEnabled
     */
    rowreq_ctx->undo->clabWIFIRadioIEEE80211hEnabled = rowreq_ctx->data.clabWIFIRadioIEEE80211hEnabled;


    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hEnabled_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioIEEE80211hEnabled_val
 *        A long containing the new value.
 */
int
clabWIFIRadioIEEE80211hEnabled_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioIEEE80211hEnabled_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hEnabled_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioIEEE80211hEnabled value.
     * set clabWIFIRadioIEEE80211hEnabled value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioIEEE80211hEnabled = clabWIFIRadioIEEE80211hEnabled_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hEnabled_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioIEEE80211hEnabled_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioIEEE80211hEnabled_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioIEEE80211hEnabled undo.
     */
    /*
     * copy clabWIFIRadioIEEE80211hEnabled data
     * set rowreq_ctx->data.clabWIFIRadioIEEE80211hEnabled from rowreq_ctx->undo->clabWIFIRadioIEEE80211hEnabled
     */
    rowreq_ctx->data.clabWIFIRadioIEEE80211hEnabled = rowreq_ctx->undo->clabWIFIRadioIEEE80211hEnabled;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioIEEE80211hEnabled_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioRegulatoryDomain
 * clabWIFIRadioRegulatoryDomain is subid 28 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.28
 * Description:
This object is defined in TR-181 Device.WiFi.Radio.{i}.RegulatoryDomain
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255t
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is SnmpAdminString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioRegulatoryDomain_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioRegulatoryDomain_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioRegulatoryDomain_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.clabWIFIRadioRegulatoryDomain).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioRegulatoryDomain_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioRegulatoryDomain_val_ptr,  size_t clabWIFIRadioRegulatoryDomain_val_ptr_len)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRegulatoryDomain_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioRegulatoryDomain_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioRegulatoryDomain value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioRegulatoryDomain value not illegal */
} /* clabWIFIRadioRegulatoryDomain_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioRegulatoryDomain_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRegulatoryDomain_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioRegulatoryDomain undo.
     */
    /*
     * copy clabWIFIRadioRegulatoryDomain and clabWIFIRadioRegulatoryDomain_len data
     * set rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain from rowreq_ctx->data.clabWIFIRadioRegulatoryDomain
     */
    memcpy( rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain, rowreq_ctx->data.clabWIFIRadioRegulatoryDomain,
            (rowreq_ctx->data.clabWIFIRadioRegulatoryDomain_len * sizeof(rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain[0])));
    rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain_len = rowreq_ctx->data.clabWIFIRadioRegulatoryDomain_len;


    return MFD_SUCCESS;
} /* clabWIFIRadioRegulatoryDomain_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioRegulatoryDomain_val_ptr
 *        A char containing the new value.
 * @param clabWIFIRadioRegulatoryDomain_val_ptr_len
 *        The size (in bytes) of the data pointed to by clabWIFIRadioRegulatoryDomain_val_ptr
 */
int
clabWIFIRadioRegulatoryDomain_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, char *clabWIFIRadioRegulatoryDomain_val_ptr,  size_t clabWIFIRadioRegulatoryDomain_val_ptr_len )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRegulatoryDomain_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != clabWIFIRadioRegulatoryDomain_val_ptr);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioRegulatoryDomain value.
     * set clabWIFIRadioRegulatoryDomain value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioRegulatoryDomain, clabWIFIRadioRegulatoryDomain_val_ptr, clabWIFIRadioRegulatoryDomain_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.clabWIFIRadioRegulatoryDomain_len = clabWIFIRadioRegulatoryDomain_val_ptr_len / sizeof(clabWIFIRadioRegulatoryDomain_val_ptr[0]);

    return MFD_SUCCESS;
} /* clabWIFIRadioRegulatoryDomain_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioRegulatoryDomain_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRegulatoryDomain_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioRegulatoryDomain undo.
     */
    /*
     * copy clabWIFIRadioRegulatoryDomain and clabWIFIRadioRegulatoryDomain_len data
     * set rowreq_ctx->data.clabWIFIRadioRegulatoryDomain from rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain
     */
    memcpy( rowreq_ctx->data.clabWIFIRadioRegulatoryDomain, rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain,
            (rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain_len * sizeof(rowreq_ctx->data.clabWIFIRadioRegulatoryDomain[0])));
    rowreq_ctx->data.clabWIFIRadioRegulatoryDomain_len = rowreq_ctx->undo->clabWIFIRadioRegulatoryDomain_len;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioRegulatoryDomain_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioNoncontiguousChannel
 * clabWIFIRadioNoncontiguousChannel is subid 29 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.29
 * Description:
This object is defined for the Noncontiguous 80+80Mhz channels
         only. It indicates the center of the second 80Mhz subchannel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioNoncontiguousChannel_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *    The value is in (one of) the range set(s):  1 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioNoncontiguousChannel_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioNoncontiguousChannel_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioNoncontiguousChannel_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioNoncontiguousChannel value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioNoncontiguousChannel value not illegal */
} /* clabWIFIRadioNoncontiguousChannel_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioNoncontiguousChannel_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioNoncontiguousChannel_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioNoncontiguousChannel undo.
     */
    /*
     * copy clabWIFIRadioNoncontiguousChannel data
     * set rowreq_ctx->undo->clabWIFIRadioNoncontiguousChannel from rowreq_ctx->data.clabWIFIRadioNoncontiguousChannel
     */
    rowreq_ctx->undo->clabWIFIRadioNoncontiguousChannel = rowreq_ctx->data.clabWIFIRadioNoncontiguousChannel;


    return MFD_SUCCESS;
} /* clabWIFIRadioNoncontiguousChannel_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioNoncontiguousChannel_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioNoncontiguousChannel_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioNoncontiguousChannel_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioNoncontiguousChannel_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioNoncontiguousChannel value.
     * set clabWIFIRadioNoncontiguousChannel value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioNoncontiguousChannel = clabWIFIRadioNoncontiguousChannel_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioNoncontiguousChannel_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioNoncontiguousChannel_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioNoncontiguousChannel_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioNoncontiguousChannel undo.
     */
    /*
     * copy clabWIFIRadioNoncontiguousChannel data
     * set rowreq_ctx->data.clabWIFIRadioNoncontiguousChannel from rowreq_ctx->undo->clabWIFIRadioNoncontiguousChannel
     */
    rowreq_ctx->data.clabWIFIRadioNoncontiguousChannel = rowreq_ctx->undo->clabWIFIRadioNoncontiguousChannel;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioNoncontiguousChannel_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioCarrierSenseThresholdInUse
 * clabWIFIRadioCarrierSenseThresholdInUse is subid 30 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.30
 * Description:
This object is the RSSI signal level at which CS/CCA detects a
         busy condition. This attribute enables APs to increase minimum
         sensitivity to avoid detecting busy condition from
         multiple/weak Wi-Fi sources in dense Wi-Fi environments.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioCarrierSenseThresholdInUse_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioCarrierSenseThresholdInUse_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioCarrierSenseThresholdInUse_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdInUse_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioCarrierSenseThresholdInUse value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioCarrierSenseThresholdInUse value not illegal */
} /* clabWIFIRadioCarrierSenseThresholdInUse_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioCarrierSenseThresholdInUse_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdInUse_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioCarrierSenseThresholdInUse undo.
     */
    /*
     * copy clabWIFIRadioCarrierSenseThresholdInUse data
     * set rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdInUse from rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdInUse
     */
    rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdInUse = rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdInUse;


    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdInUse_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioCarrierSenseThresholdInUse_val
 *        A long containing the new value.
 */
int
clabWIFIRadioCarrierSenseThresholdInUse_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioCarrierSenseThresholdInUse_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdInUse_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioCarrierSenseThresholdInUse value.
     * set clabWIFIRadioCarrierSenseThresholdInUse value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdInUse = clabWIFIRadioCarrierSenseThresholdInUse_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdInUse_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioCarrierSenseThresholdInUse_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdInUse_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioCarrierSenseThresholdInUse undo.
     */
    /*
     * copy clabWIFIRadioCarrierSenseThresholdInUse data
     * set rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdInUse from rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdInUse
     */
    rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdInUse = rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdInUse;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdInUse_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioCarrierSenseThresholdRange
 * clabWIFIRadioCarrierSenseThresholdRange is subid 31 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.31
 * Description:
This object indicates the Carrier Sense ranges supported by
         the radio.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioCarrierSenseThresholdRange_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioCarrierSenseThresholdRange_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioCarrierSenseThresholdRange_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdRange_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioCarrierSenseThresholdRange value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioCarrierSenseThresholdRange value not illegal */
} /* clabWIFIRadioCarrierSenseThresholdRange_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioCarrierSenseThresholdRange_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdRange_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioCarrierSenseThresholdRange undo.
     */
    /*
     * copy clabWIFIRadioCarrierSenseThresholdRange data
     * set rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdRange from rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdRange
     */
    rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdRange = rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdRange;


    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdRange_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioCarrierSenseThresholdRange_val
 *        A long containing the new value.
 */
int
clabWIFIRadioCarrierSenseThresholdRange_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioCarrierSenseThresholdRange_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdRange_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioCarrierSenseThresholdRange value.
     * set clabWIFIRadioCarrierSenseThresholdRange value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdRange = clabWIFIRadioCarrierSenseThresholdRange_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdRange_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioCarrierSenseThresholdRange_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioCarrierSenseThresholdRange_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioCarrierSenseThresholdRange undo.
     */
    /*
     * copy clabWIFIRadioCarrierSenseThresholdRange data
     * set rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdRange from rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdRange
     */
    rowreq_ctx->data.clabWIFIRadioCarrierSenseThresholdRange = rowreq_ctx->undo->clabWIFIRadioCarrierSenseThresholdRange;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioCarrierSenseThresholdRange_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioStatsChanUtilization
 * clabWIFIRadioStatsChanUtilization is subid 32 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.32
 * Description:
This object indicates the fraction of the time AP senses a busy
         channel or transmits frames. This object provides visibility
         into channel capacity.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioStatsChanUtilization_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioStatsChanUtilization_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioStatsChanUtilization_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatsChanUtilization_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioStatsChanUtilization value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioStatsChanUtilization value not illegal */
} /* clabWIFIRadioStatsChanUtilization_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioStatsChanUtilization_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatsChanUtilization_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioStatsChanUtilization undo.
     */
    /*
     * copy clabWIFIRadioStatsChanUtilization data
     * set rowreq_ctx->undo->clabWIFIRadioStatsChanUtilization from rowreq_ctx->data.clabWIFIRadioStatsChanUtilization
     */
    rowreq_ctx->undo->clabWIFIRadioStatsChanUtilization = rowreq_ctx->data.clabWIFIRadioStatsChanUtilization;


    return MFD_SUCCESS;
} /* clabWIFIRadioStatsChanUtilization_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioStatsChanUtilization_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioStatsChanUtilization_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioStatsChanUtilization_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatsChanUtilization_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioStatsChanUtilization value.
     * set clabWIFIRadioStatsChanUtilization value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioStatsChanUtilization = clabWIFIRadioStatsChanUtilization_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioStatsChanUtilization_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioStatsChanUtilization_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioStatsChanUtilization_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioStatsChanUtilization undo.
     */
    /*
     * copy clabWIFIRadioStatsChanUtilization data
     * set rowreq_ctx->data.clabWIFIRadioStatsChanUtilization from rowreq_ctx->undo->clabWIFIRadioStatsChanUtilization
     */
    rowreq_ctx->data.clabWIFIRadioStatsChanUtilization = rowreq_ctx->undo->clabWIFIRadioStatsChanUtilization;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioStatsChanUtilization_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioRtsCtsExchange
 * clabWIFIRadioRtsCtsExchange is subid 33 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.33
 * Description:
This object allows configuring the RTS/CTS parameters.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioRtsCtsExchange_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioRtsCtsExchange_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioRtsCtsExchange_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRtsCtsExchange_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioRtsCtsExchange value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioRtsCtsExchange value not illegal */
} /* clabWIFIRadioRtsCtsExchange_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioRtsCtsExchange_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRtsCtsExchange_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioRtsCtsExchange undo.
     */
    /*
     * copy clabWIFIRadioRtsCtsExchange data
     * set rowreq_ctx->undo->clabWIFIRadioRtsCtsExchange from rowreq_ctx->data.clabWIFIRadioRtsCtsExchange
     */
    rowreq_ctx->undo->clabWIFIRadioRtsCtsExchange = rowreq_ctx->data.clabWIFIRadioRtsCtsExchange;


    return MFD_SUCCESS;
} /* clabWIFIRadioRtsCtsExchange_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioRtsCtsExchange_val
 *        A long containing the new value.
 */
int
clabWIFIRadioRtsCtsExchange_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioRtsCtsExchange_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRtsCtsExchange_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioRtsCtsExchange value.
     * set clabWIFIRadioRtsCtsExchange value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioRtsCtsExchange = clabWIFIRadioRtsCtsExchange_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioRtsCtsExchange_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioRtsCtsExchange_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioRtsCtsExchange_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioRtsCtsExchange undo.
     */
    /*
     * copy clabWIFIRadioRtsCtsExchange data
     * set rowreq_ctx->data.clabWIFIRadioRtsCtsExchange from rowreq_ctx->undo->clabWIFIRadioRtsCtsExchange
     */
    rowreq_ctx->data.clabWIFIRadioRtsCtsExchange = rowreq_ctx->undo->clabWIFIRadioRtsCtsExchange;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioRtsCtsExchange_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioFrameAggregationLevel
 * clabWIFIRadioFrameAggregationLevel is subid 34 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.34
 * Description:
This object allows configuring the frame aggregation level
         depending on how dense the network is. For example, if the
         network is not congested, then a large number of frames can
         be aggregated and sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioFrameAggregationLevel_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioFrameAggregationLevel_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioFrameAggregationLevel_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioFrameAggregationLevel_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioFrameAggregationLevel value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioFrameAggregationLevel value not illegal */
} /* clabWIFIRadioFrameAggregationLevel_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioFrameAggregationLevel_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioFrameAggregationLevel_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioFrameAggregationLevel undo.
     */
    /*
     * copy clabWIFIRadioFrameAggregationLevel data
     * set rowreq_ctx->undo->clabWIFIRadioFrameAggregationLevel from rowreq_ctx->data.clabWIFIRadioFrameAggregationLevel
     */
    rowreq_ctx->undo->clabWIFIRadioFrameAggregationLevel = rowreq_ctx->data.clabWIFIRadioFrameAggregationLevel;


    return MFD_SUCCESS;
} /* clabWIFIRadioFrameAggregationLevel_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioFrameAggregationLevel_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioFrameAggregationLevel_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioFrameAggregationLevel_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioFrameAggregationLevel_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioFrameAggregationLevel value.
     * set clabWIFIRadioFrameAggregationLevel value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioFrameAggregationLevel = clabWIFIRadioFrameAggregationLevel_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioFrameAggregationLevel_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioFrameAggregationLevel_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioFrameAggregationLevel_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioFrameAggregationLevel undo.
     */
    /*
     * copy clabWIFIRadioFrameAggregationLevel data
     * set rowreq_ctx->data.clabWIFIRadioFrameAggregationLevel from rowreq_ctx->undo->clabWIFIRadioFrameAggregationLevel
     */
    rowreq_ctx->data.clabWIFIRadioFrameAggregationLevel = rowreq_ctx->undo->clabWIFIRadioFrameAggregationLevel;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioFrameAggregationLevel_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioThroughput
 * clabWIFIRadioThroughput is subid 35 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.35
 * Description:
This object indicates the throughput expressed in Mbps.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioThroughput_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioThroughput_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioThroughput_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioThroughput_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioThroughput value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioThroughput value not illegal */
} /* clabWIFIRadioThroughput_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioThroughput_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioThroughput_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioThroughput undo.
     */
    /*
     * copy clabWIFIRadioThroughput data
     * set rowreq_ctx->undo->clabWIFIRadioThroughput from rowreq_ctx->data.clabWIFIRadioThroughput
     */
    rowreq_ctx->undo->clabWIFIRadioThroughput = rowreq_ctx->data.clabWIFIRadioThroughput;


    return MFD_SUCCESS;
} /* clabWIFIRadioThroughput_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioThroughput_val
 *        A u_long containing the new value.
 */
int
clabWIFIRadioThroughput_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, u_long clabWIFIRadioThroughput_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioThroughput_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioThroughput value.
     * set clabWIFIRadioThroughput value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioThroughput = clabWIFIRadioThroughput_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioThroughput_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioThroughput_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioThroughput_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioThroughput undo.
     */
    /*
     * copy clabWIFIRadioThroughput data
     * set rowreq_ctx->data.clabWIFIRadioThroughput from rowreq_ctx->undo->clabWIFIRadioThroughput
     */
    rowreq_ctx->data.clabWIFIRadioThroughput = rowreq_ctx->undo->clabWIFIRadioThroughput;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioThroughput_undo */

/*---------------------------------------------------------------------
 * CLAB-WIFI-MIB::clabWIFIRadioEntry.clabWIFIRadioPktErrorRateSTA
 * clabWIFIRadioPktErrorRateSTA is subid 36 of clabWIFIRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4491.2.5.1.1.2.1.36
 * Description:
This object indicates the traffic quality (e.g., HTTP, TCP)
         of an STA.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: d-9
 *
 *
 * Its syntax is PktErrorRateType (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param clabWIFIRadioPktErrorRateSTA_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * clabWIFIRadioTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
clabWIFIRadioPktErrorRateSTA_check_value( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioPktErrorRateSTA_val)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPktErrorRateSTA_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid clabWIFIRadioPktErrorRateSTA value.
     */

    return MFD_SUCCESS; /* clabWIFIRadioPktErrorRateSTA value not illegal */
} /* clabWIFIRadioPktErrorRateSTA_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (clabWIFIRadioTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * clabWIFIRadioTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
clabWIFIRadioPktErrorRateSTA_undo_setup( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPktErrorRateSTA_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup clabWIFIRadioPktErrorRateSTA undo.
     */
    /*
     * copy clabWIFIRadioPktErrorRateSTA data
     * set rowreq_ctx->undo->clabWIFIRadioPktErrorRateSTA from rowreq_ctx->data.clabWIFIRadioPktErrorRateSTA
     */
    rowreq_ctx->undo->clabWIFIRadioPktErrorRateSTA = rowreq_ctx->data.clabWIFIRadioPktErrorRateSTA;


    return MFD_SUCCESS;
} /* clabWIFIRadioPktErrorRateSTA_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param clabWIFIRadioPktErrorRateSTA_val
 *        A long containing the new value.
 */
int
clabWIFIRadioPktErrorRateSTA_set( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx, long clabWIFIRadioPktErrorRateSTA_val )
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPktErrorRateSTA_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set clabWIFIRadioPktErrorRateSTA value.
     * set clabWIFIRadioPktErrorRateSTA value in rowreq_ctx->data
     */
    rowreq_ctx->data.clabWIFIRadioPktErrorRateSTA = clabWIFIRadioPktErrorRateSTA_val;

    return MFD_SUCCESS;
} /* clabWIFIRadioPktErrorRateSTA_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
clabWIFIRadioPktErrorRateSTA_undo( clabWIFIRadioTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:clabWIFIRadioTable:clabWIFIRadioPktErrorRateSTA_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up clabWIFIRadioPktErrorRateSTA undo.
     */
    /*
     * copy clabWIFIRadioPktErrorRateSTA data
     * set rowreq_ctx->data.clabWIFIRadioPktErrorRateSTA from rowreq_ctx->undo->clabWIFIRadioPktErrorRateSTA
     */
    rowreq_ctx->data.clabWIFIRadioPktErrorRateSTA = rowreq_ctx->undo->clabWIFIRadioPktErrorRateSTA;

    
    return MFD_SUCCESS;
} /* clabWIFIRadioPktErrorRateSTA_undo */

/** @} */
