/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11BssTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11BssTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRCM-80211-MGMT-MIB::dot11BssTable is subid 14 of dot11MbssBase.
 * Its status is Deprecated.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14, length: 15
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11BssTable_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup dot11BssTable undo.
     * set up dot11BssTable undo information, in preparation for a set.
     * Undo storage is in (* dot11BssAccessMode_val_ptr )*
     */

    return rc;
} /* dot11BssTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11BssTable_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> dot11BssTable undo.
     * dot11BssTable undo information, in response to a failed set.
     * Undo storage is in (* dot11BssAccessMode_val_ptr )*
     */

    return rc;
} /* dot11BssTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11BssTable_undo_cleanup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup dot11BssTable undo.
     * Undo storage is in (* dot11BssAccessMode_val_ptr )*
     */

    return rc;
} /* dot11BssTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11BssTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11BssTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11BssTable_commit( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit dot11BssTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_DOT11BSSID_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSID_FLAG; /* clear dot11BssId */
       /*
        * TODO:482:o: |-> commit column dot11BssId.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssId commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssId
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSID_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSENABLE_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSENABLE_FLAG; /* clear dot11BssEnable */
       /*
        * TODO:482:o: |-> commit column dot11BssEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSSSID_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSSSID_FLAG; /* clear dot11BssSsid */
       /*
        * TODO:482:o: |-> commit column dot11BssSsid.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssSsid commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssSsid
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSSSID_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSNETWORKBRIDGE_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSNETWORKBRIDGE_FLAG; /* clear dot11BssNetworkBridge */
       /*
        * TODO:482:o: |-> commit column dot11BssNetworkBridge.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssNetworkBridge commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssNetworkBridge
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSNETWORKBRIDGE_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSSECURITYMODE_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSSECURITYMODE_FLAG; /* clear dot11BssSecurityMode */
       /*
        * TODO:482:o: |-> commit column dot11BssSecurityMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssSecurityMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssSecurityMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSSECURITYMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSCLOSEDNETWORK_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSCLOSEDNETWORK_FLAG; /* clear dot11BssClosedNetwork */
       /*
        * TODO:482:o: |-> commit column dot11BssClosedNetwork.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssClosedNetwork commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssClosedNetwork
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSCLOSEDNETWORK_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT11BSSACCESSMODE_FLAG) {
       save_flags &= ~COLUMN_DOT11BSSACCESSMODE_FLAG; /* clear dot11BssAccessMode */
       /*
        * TODO:482:o: |-> commit column dot11BssAccessMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11BssTable column dot11BssAccessMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot11BssAccessMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT11BSSACCESSMODE_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* dot11BssTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11BssTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11BssTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11BssTable_undo_commit( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo dot11BssTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* dot11BssTable_undo_commit */

/*
 * TODO:440:M: Implement dot11BssTable node value checks.
 * TODO:450:M: Implement dot11BssTable undo functions.
 * TODO:460:M: Implement dot11BssTable set functions.
 * TODO:480:M: Implement dot11BssTable commit functions.
 */
/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssId
 * dot11BssId is subid 1 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.1
 * Description:
The physical address associated with this service set.

         This object has been deprecated in favor of the wifiBssId object in
         wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssId_val_ptr
 *        A char containing the new value.
 * @param dot11BssId_val_ptr_len
 *        The size (in bytes) of the data pointed to by dot11BssId_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.dot11BssId).
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssId_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, char *dot11BssId_val_ptr,  size_t dot11BssId_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssId_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != dot11BssId_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid dot11BssId value.
     */

    return MFD_SUCCESS; /* dot11BssId value not illegal */
} /* dot11BssId_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssId_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssId_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssId undo.
     */
    /*
     * copy dot11BssId and dot11BssId_len data
     * set rowreq_ctx->undo->dot11BssId from rowreq_ctx->data.dot11BssId
     */
    memcpy( rowreq_ctx->undo->dot11BssId, rowreq_ctx->data.dot11BssId,
            (rowreq_ctx->data.dot11BssId_len * sizeof(rowreq_ctx->undo->dot11BssId[0])));
    rowreq_ctx->undo->dot11BssId_len = rowreq_ctx->data.dot11BssId_len;


    return MFD_SUCCESS;
} /* dot11BssId_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssId_val_ptr
 *        A char containing the new value.
 * @param dot11BssId_val_ptr_len
 *        The size (in bytes) of the data pointed to by dot11BssId_val_ptr
 */
int
dot11BssId_set( dot11BssTable_rowreq_ctx *rowreq_ctx, char *dot11BssId_val_ptr,  size_t dot11BssId_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssId_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != dot11BssId_val_ptr);

    /*
     * TODO:461:M: |-> Set dot11BssId value.
     * set dot11BssId value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.dot11BssId, dot11BssId_val_ptr, dot11BssId_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.dot11BssId_len = dot11BssId_val_ptr_len / sizeof(dot11BssId_val_ptr[0]);

    return MFD_SUCCESS;
} /* dot11BssId_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssId_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssId_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssId undo.
     */
    /*
     * copy dot11BssId and dot11BssId_len data
     * set rowreq_ctx->data.dot11BssId from rowreq_ctx->undo->dot11BssId
     */
    memcpy( rowreq_ctx->data.dot11BssId, rowreq_ctx->undo->dot11BssId,
            (rowreq_ctx->undo->dot11BssId_len * sizeof(rowreq_ctx->data.dot11BssId[0])));
    rowreq_ctx->data.dot11BssId_len = rowreq_ctx->undo->dot11BssId_len;

    
    return MFD_SUCCESS;
} /* dot11BssId_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssEnable
 * dot11BssEnable is subid 2 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.2
 * Description:
Enables or disables this service set.

         This object has been deprecated in favor of the wifiBssEnable object in
         wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssEnable_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssEnable_val)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot11BssEnable value.
     */

    return MFD_SUCCESS; /* dot11BssEnable value not illegal */
} /* dot11BssEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssEnable_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssEnable undo.
     */
    /*
     * copy dot11BssEnable data
     * set rowreq_ctx->undo->dot11BssEnable from rowreq_ctx->data.dot11BssEnable
     */
    rowreq_ctx->undo->dot11BssEnable = rowreq_ctx->data.dot11BssEnable;


    return MFD_SUCCESS;
} /* dot11BssEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssEnable_val
 *        A long containing the new value.
 */
int
dot11BssEnable_set( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssEnable_val )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot11BssEnable value.
     * set dot11BssEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot11BssEnable = dot11BssEnable_val;

    return MFD_SUCCESS;
} /* dot11BssEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssEnable_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssEnable undo.
     */
    /*
     * copy dot11BssEnable data
     * set rowreq_ctx->data.dot11BssEnable from rowreq_ctx->undo->dot11BssEnable
     */
    rowreq_ctx->data.dot11BssEnable = rowreq_ctx->undo->dot11BssEnable;

    
    return MFD_SUCCESS;
} /* dot11BssEnable_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssSsid
 * dot11BssSsid is subid 3 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.3
 * Description:
Controls and reflects the service set identifier for this BSS.

         This object has been deprecated in favor of the wifiBssSsid object in
         wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 32;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 32)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssSsid_val_ptr
 *        A char containing the new value.
 * @param dot11BssSsid_val_ptr_len
 *        The size (in bytes) of the data pointed to by dot11BssSsid_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.dot11BssSsid).
 *    The length is in (one of) the range set(s):  0 - 32
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssSsid_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, char *dot11BssSsid_val_ptr,  size_t dot11BssSsid_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSsid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != dot11BssSsid_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid dot11BssSsid value.
     */

    return MFD_SUCCESS; /* dot11BssSsid value not illegal */
} /* dot11BssSsid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssSsid_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSsid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssSsid undo.
     */
    /*
     * copy dot11BssSsid and dot11BssSsid_len data
     * set rowreq_ctx->undo->dot11BssSsid from rowreq_ctx->data.dot11BssSsid
     */
    memcpy( rowreq_ctx->undo->dot11BssSsid, rowreq_ctx->data.dot11BssSsid,
            (rowreq_ctx->data.dot11BssSsid_len * sizeof(rowreq_ctx->undo->dot11BssSsid[0])));
    rowreq_ctx->undo->dot11BssSsid_len = rowreq_ctx->data.dot11BssSsid_len;


    return MFD_SUCCESS;
} /* dot11BssSsid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssSsid_val_ptr
 *        A char containing the new value.
 * @param dot11BssSsid_val_ptr_len
 *        The size (in bytes) of the data pointed to by dot11BssSsid_val_ptr
 */
int
dot11BssSsid_set( dot11BssTable_rowreq_ctx *rowreq_ctx, char *dot11BssSsid_val_ptr,  size_t dot11BssSsid_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSsid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != dot11BssSsid_val_ptr);

    /*
     * TODO:461:M: |-> Set dot11BssSsid value.
     * set dot11BssSsid value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.dot11BssSsid, dot11BssSsid_val_ptr, dot11BssSsid_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.dot11BssSsid_len = dot11BssSsid_val_ptr_len / sizeof(dot11BssSsid_val_ptr[0]);

    return MFD_SUCCESS;
} /* dot11BssSsid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssSsid_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSsid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssSsid undo.
     */
    /*
     * copy dot11BssSsid and dot11BssSsid_len data
     * set rowreq_ctx->data.dot11BssSsid from rowreq_ctx->undo->dot11BssSsid
     */
    memcpy( rowreq_ctx->data.dot11BssSsid, rowreq_ctx->undo->dot11BssSsid,
            (rowreq_ctx->undo->dot11BssSsid_len * sizeof(rowreq_ctx->data.dot11BssSsid[0])));
    rowreq_ctx->data.dot11BssSsid_len = rowreq_ctx->undo->dot11BssSsid_len;

    
    return MFD_SUCCESS;
} /* dot11BssSsid_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssNetworkBridge
 * dot11BssNetworkBridge is subid 4 of dot11BssEntry.
 * Its status is Obsolete, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.4
 * Description:
If set to lan(1), this service set will be authorized as a member of
         the local area network.  If set to guest(2), this service set will
         have access to the wide area internet, but will have restricted access
         to the local area network.

         This object has been deprecated in favor of the wifiBssNetworkBridge
         object in the wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  lan(1), guest(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssNetworkBridge_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  lan(1), guest(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssNetworkBridge_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssNetworkBridge_val)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssNetworkBridge_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot11BssNetworkBridge value.
     */

    return MFD_SUCCESS; /* dot11BssNetworkBridge value not illegal */
} /* dot11BssNetworkBridge_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssNetworkBridge_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssNetworkBridge_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssNetworkBridge undo.
     */
    /*
     * copy dot11BssNetworkBridge data
     * set rowreq_ctx->undo->dot11BssNetworkBridge from rowreq_ctx->data.dot11BssNetworkBridge
     */
    rowreq_ctx->undo->dot11BssNetworkBridge = rowreq_ctx->data.dot11BssNetworkBridge;


    return MFD_SUCCESS;
} /* dot11BssNetworkBridge_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssNetworkBridge_val
 *        A long containing the new value.
 */
int
dot11BssNetworkBridge_set( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssNetworkBridge_val )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssNetworkBridge_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot11BssNetworkBridge value.
     * set dot11BssNetworkBridge value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot11BssNetworkBridge = dot11BssNetworkBridge_val;

    return MFD_SUCCESS;
} /* dot11BssNetworkBridge_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssNetworkBridge_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssNetworkBridge_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssNetworkBridge undo.
     */
    /*
     * copy dot11BssNetworkBridge data
     * set rowreq_ctx->data.dot11BssNetworkBridge from rowreq_ctx->undo->dot11BssNetworkBridge
     */
    rowreq_ctx->data.dot11BssNetworkBridge = rowreq_ctx->undo->dot11BssNetworkBridge;

    
    return MFD_SUCCESS;
} /* dot11BssNetworkBridge_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssSecurityMode
 * dot11BssSecurityMode is subid 5 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.5
 * Description:
Security mode may be chosen from Disable, WEP, WPA-PSK, WPA2-PSK,
         WPA-Enterprise, WPA2-Enterprise or RADIUS-WEP.  All devices on the 
         network must use the same security mode in order to communicate.

         If set to disabled(0):
            Open system. No authentication or encryption.

         If set to wep(1) then the following parameters must be set:
            Default Transmit Key (dot11BssWepDefaultKey):
                Choose which Key to use.
            WEP Key Bit (dot11BssWepEncryptionMode):
                May select from 64-Bit or 128-Bit encryption.
            Passphrase (dot11BssWepPassPhrase):
                Enter a passphrase consisting of any keyboard character
                to be used to generate a hex WEP key.
            Key 1-4 (dot11BssWep64BitKeyTable or dot11BssWep128BitKeyTable):
                Enter a WEP key manually. Must use only hex character (0-9 and A-F).
                64-bit WEP requires 10 hex characters, 128-Bit WEP requires the use of
                26 hex characters.
                
         If set to wpaPsk(2) then the following parameters must be set:
            WPA Algorithm (dot11BssWpaAlgorithm):
                TKIP or AES.
            WPA Pre-Shared Key (dot11BssWpaPreSharedKey):
                Choose a unique key to authenticate with other devices on the network.
                The Pre-Shared Key must be between 8 and 63 characters in length.
            Group Key Renewal (dot11BssWpaGroupRekeyInterval):
                This settingss determines how often the group key changes.

         If set to wpa2Psk(3) then the following parameters must be set:
            WPA2 Algorithm (dot11BssWpaAlgorithm):
                AES or TKIP+AES.
            WPA2 Pre-Shared Key (dot11BssWpaPreSharedKey):
                Choose a unique key to authenticate with other devices on the network.
                The Pre-Shared Key must be between 8 and 63 characters in length.
            Group Key Renewal (dot11BssWpaGroupRekeyInterval):
                This settingss determines how often the group key changes.
                
         If set to wpaEnterprise(4) then the following parameters must be set:
            WPA Algorithm (dot11BssWpaAlgorithm):
                TKIP or AES.
            RADIUS Server Address (dot11BssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (dot11BssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (dot11BssRadiusKey):
                The shared secret set on the RADIUS server.
            Key Renewal Timeout (dot11BssRadiusReAuthInterval):
                Determines how often the keys should be renened.
                
         If set to wpa2Enterprise(5) then the following parameters must be set:
            WPA2 Algorithm (dot11BssWpaAlgorithm):
                AES or TKIP+AES.
            RADIUS Server Address (dot11BssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (dot11BssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (dot11BssRadiusKey):
                The shared secret set on the RADIUS server.
            Key Renewal Timeout (dot11BssRadiusReAuthInterval):
                Determines how often the keys should be renened.
                
         If set to radiusWep(6) then the following parameters must be set:
            RADIUS Server Address (dot11BssRadiusAddressType / dot11BssRadiusAddress):
                The IP address of the RADIUS server.
            RADIUS Server Port (dot11BssRadiusPort):
                The port the RADIUS server uses.
            RADIUS Shared Secret (dot11BssRadiusKey):
                The shared secret set on the RADIUS server.
            Default Transmit Key (dot11BssWepDefaultKey):
                Choose which Key to use.
            WEP Key Bit (dot11BssWepEncryptionMode):
                May select from 64-Bit or 128-Bit encryption.
            Passphrase (dot11BssWepPassPhrase):
        
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 7/16. Values:  disabled(0), wep(1), wpaPsk(2), wpa2Psk(3), wpaEnterprise(4), wpa2Enterprise(5), radiusWep(6), wpaWpa2Psk(7), wpaWpa2Enterprise(8)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssSecurityMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  disabled(0), wep(1), wpaPsk(2), wpa2Psk(3), wpaEnterprise(4), wpa2Enterprise(5), radiusWep(6), wpaWpa2Psk(7), wpaWpa2Enterprise(8)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssSecurityMode_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssSecurityMode_val)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSecurityMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot11BssSecurityMode value.
     */

    return MFD_SUCCESS; /* dot11BssSecurityMode value not illegal */
} /* dot11BssSecurityMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssSecurityMode_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSecurityMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssSecurityMode undo.
     */
    /*
     * copy dot11BssSecurityMode data
     * set rowreq_ctx->undo->dot11BssSecurityMode from rowreq_ctx->data.dot11BssSecurityMode
     */
    rowreq_ctx->undo->dot11BssSecurityMode = rowreq_ctx->data.dot11BssSecurityMode;


    return MFD_SUCCESS;
} /* dot11BssSecurityMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssSecurityMode_val
 *        A long containing the new value.
 */
int
dot11BssSecurityMode_set( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssSecurityMode_val )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSecurityMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot11BssSecurityMode value.
     * set dot11BssSecurityMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot11BssSecurityMode = dot11BssSecurityMode_val;

    return MFD_SUCCESS;
} /* dot11BssSecurityMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssSecurityMode_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssSecurityMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssSecurityMode undo.
     */
    /*
     * copy dot11BssSecurityMode data
     * set rowreq_ctx->data.dot11BssSecurityMode from rowreq_ctx->undo->dot11BssSecurityMode
     */
    rowreq_ctx->data.dot11BssSecurityMode = rowreq_ctx->undo->dot11BssSecurityMode;

    
    return MFD_SUCCESS;
} /* dot11BssSecurityMode_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssClosedNetwork
 * dot11BssClosedNetwork is subid 6 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.6
 * Description:
Controls whether the device will operate in closed network mode.  If
         set to true(1), then the network mode is closed and the SSID will not
         be broadcast in beacon packets.  If set to false(2), then the network
         mode is open and the SSID will be broadcast in beacon packets.

         This object has been deprecated in favor of the wifiBssClosedNetwork
         object in the wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssClosedNetwork_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssClosedNetwork_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssClosedNetwork_val)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssClosedNetwork_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot11BssClosedNetwork value.
     */

    return MFD_SUCCESS; /* dot11BssClosedNetwork value not illegal */
} /* dot11BssClosedNetwork_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssClosedNetwork_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssClosedNetwork_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssClosedNetwork undo.
     */
    /*
     * copy dot11BssClosedNetwork data
     * set rowreq_ctx->undo->dot11BssClosedNetwork from rowreq_ctx->data.dot11BssClosedNetwork
     */
    rowreq_ctx->undo->dot11BssClosedNetwork = rowreq_ctx->data.dot11BssClosedNetwork;


    return MFD_SUCCESS;
} /* dot11BssClosedNetwork_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssClosedNetwork_val
 *        A long containing the new value.
 */
int
dot11BssClosedNetwork_set( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssClosedNetwork_val )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssClosedNetwork_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot11BssClosedNetwork value.
     * set dot11BssClosedNetwork value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot11BssClosedNetwork = dot11BssClosedNetwork_val;

    return MFD_SUCCESS;
} /* dot11BssClosedNetwork_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssClosedNetwork_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssClosedNetwork_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssClosedNetwork undo.
     */
    /*
     * copy dot11BssClosedNetwork data
     * set rowreq_ctx->data.dot11BssClosedNetwork from rowreq_ctx->undo->dot11BssClosedNetwork
     */
    rowreq_ctx->data.dot11BssClosedNetwork = rowreq_ctx->undo->dot11BssClosedNetwork;

    
    return MFD_SUCCESS;
} /* dot11BssClosedNetwork_undo */

/*---------------------------------------------------------------------
 * BRCM-80211-MGMT-MIB::dot11BssEntry.dot11BssAccessMode
 * dot11BssAccessMode is subid 7 of dot11BssEntry.
 * Its status is Deprecated, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.4413.2.2.2.1.5.4.1.14.1.7
 * Description:
Controls what stations will be given access to the device.  If set to
         allowAny(1), then any station will be allowed to connect.  If set
         to restrictToList(2), then only stations whose MAC address appears in
         the dot11BssAccessTable will be allowed to connect.  If set to 
         denyList(3), any station will be allowed to connect except those in 
         the dot11BssAccessTable.

         This object has been deprecated in favor of the wifiBssAccessMode
         object in the wifiBssTable, from the BRCM-WIFI-MGMT-MIB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  allowAny(1), allowList(2), denyList(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot11BssAccessMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11BssTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  allowAny(1), allowList(2), denyList(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot11BssAccessMode_check_value( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssAccessMode_val)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssAccessMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot11BssAccessMode value.
     */

    return MFD_SUCCESS; /* dot11BssAccessMode value not illegal */
} /* dot11BssAccessMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11BssTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11BssTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot11BssAccessMode_undo_setup( dot11BssTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssAccessMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot11BssAccessMode undo.
     */
    /*
     * copy dot11BssAccessMode data
     * set rowreq_ctx->undo->dot11BssAccessMode from rowreq_ctx->data.dot11BssAccessMode
     */
    rowreq_ctx->undo->dot11BssAccessMode = rowreq_ctx->data.dot11BssAccessMode;


    return MFD_SUCCESS;
} /* dot11BssAccessMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot11BssAccessMode_val
 *        A long containing the new value.
 */
int
dot11BssAccessMode_set( dot11BssTable_rowreq_ctx *rowreq_ctx, u_long dot11BssAccessMode_val )
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssAccessMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot11BssAccessMode value.
     * set dot11BssAccessMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot11BssAccessMode = dot11BssAccessMode_val;

    return MFD_SUCCESS;
} /* dot11BssAccessMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot11BssAccessMode_undo( dot11BssTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11BssTable:dot11BssAccessMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot11BssAccessMode undo.
     */
    /*
     * copy dot11BssAccessMode data
     * set rowreq_ctx->data.dot11BssAccessMode from rowreq_ctx->undo->dot11BssAccessMode
     */
    rowreq_ctx->data.dot11BssAccessMode = rowreq_ctx->undo->dot11BssAccessMode;

    
    return MFD_SUCCESS;
} /* dot11BssAccessMode_undo */

/** @} */
