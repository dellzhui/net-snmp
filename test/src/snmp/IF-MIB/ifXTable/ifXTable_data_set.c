/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "ifXTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ifXTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * IF-MIB::ifXTable is subid 1 of ifMIBObjects.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.31.1.1, length: 9
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ifXTable_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifXTable:ifXTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup ifXTable undo.
     * set up ifXTable undo information, in preparation for a set.
     * Undo storage is in (* ifCounterDiscontinuityTime_val_ptr )*
     */

    return rc;
} /* ifXTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ifXTable_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifXTable:ifXTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> ifXTable undo.
     * ifXTable undo information, in response to a failed set.
     * Undo storage is in (* ifCounterDiscontinuityTime_val_ptr )*
     */

    return rc;
} /* ifXTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifXTable_undo_cleanup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifXTable:ifXTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup ifXTable undo.
     * Undo storage is in (* ifCounterDiscontinuityTime_val_ptr )*
     */

    return rc;
} /* ifXTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ifXTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ifXTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifXTable_commit( ifXTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:ifXTable:ifXTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit ifXTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_IFNAME_FLAG) {
       save_flags &= ~COLUMN_IFNAME_FLAG; /* clear ifName */
       /*
        * TODO:482:o: |-> commit column ifName.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifName commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifName
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFNAME_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINMULTICASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFINMULTICASTPKTS_FLAG; /* clear ifInMulticastPkts */
       /*
        * TODO:482:o: |-> commit column ifInMulticastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifInMulticastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInMulticastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINMULTICASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFINBROADCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFINBROADCASTPKTS_FLAG; /* clear ifInBroadcastPkts */
       /*
        * TODO:482:o: |-> commit column ifInBroadcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifInBroadcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifInBroadcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFINBROADCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTMULTICASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFOUTMULTICASTPKTS_FLAG; /* clear ifOutMulticastPkts */
       /*
        * TODO:482:o: |-> commit column ifOutMulticastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifOutMulticastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutMulticastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTMULTICASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFOUTBROADCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFOUTBROADCASTPKTS_FLAG; /* clear ifOutBroadcastPkts */
       /*
        * TODO:482:o: |-> commit column ifOutBroadcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifOutBroadcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifOutBroadcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFOUTBROADCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCINOCTETS_FLAG) {
       save_flags &= ~COLUMN_IFHCINOCTETS_FLAG; /* clear ifHCInOctets */
       /*
        * TODO:482:o: |-> commit column ifHCInOctets.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCInOctets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCInOctets
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCINOCTETS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCINUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCINUCASTPKTS_FLAG; /* clear ifHCInUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCInUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCInUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCInUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCINUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCINMULTICASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCINMULTICASTPKTS_FLAG; /* clear ifHCInMulticastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCInMulticastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCInMulticastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCInMulticastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCINMULTICASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCINBROADCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCINBROADCASTPKTS_FLAG; /* clear ifHCInBroadcastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCInBroadcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCInBroadcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCInBroadcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCINBROADCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCOUTOCTETS_FLAG) {
       save_flags &= ~COLUMN_IFHCOUTOCTETS_FLAG; /* clear ifHCOutOctets */
       /*
        * TODO:482:o: |-> commit column ifHCOutOctets.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCOutOctets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCOutOctets
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCOUTOCTETS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCOUTUCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCOUTUCASTPKTS_FLAG; /* clear ifHCOutUcastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCOutUcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCOutUcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCOutUcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCOUTUCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCOUTMULTICASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCOUTMULTICASTPKTS_FLAG; /* clear ifHCOutMulticastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCOutMulticastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCOutMulticastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCOutMulticastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCOUTMULTICASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHCOUTBROADCASTPKTS_FLAG) {
       save_flags &= ~COLUMN_IFHCOUTBROADCASTPKTS_FLAG; /* clear ifHCOutBroadcastPkts */
       /*
        * TODO:482:o: |-> commit column ifHCOutBroadcastPkts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHCOutBroadcastPkts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHCOutBroadcastPkts
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHCOUTBROADCASTPKTS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFLINKUPDOWNTRAPENABLE_FLAG) {
       save_flags &= ~COLUMN_IFLINKUPDOWNTRAPENABLE_FLAG; /* clear ifLinkUpDownTrapEnable */
       /*
        * TODO:482:o: |-> commit column ifLinkUpDownTrapEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifLinkUpDownTrapEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifLinkUpDownTrapEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFLINKUPDOWNTRAPENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_IFHIGHSPEED_FLAG) {
       save_flags &= ~COLUMN_IFHIGHSPEED_FLAG; /* clear ifHighSpeed */
       /*
        * TODO:482:o: |-> commit column ifHighSpeed.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifHighSpeed commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifHighSpeed
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFHIGHSPEED_FLAG;
       }
    }

    if (save_flags & COLUMN_IFPROMISCUOUSMODE_FLAG) {
       save_flags &= ~COLUMN_IFPROMISCUOUSMODE_FLAG; /* clear ifPromiscuousMode */
       /*
        * TODO:482:o: |-> commit column ifPromiscuousMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifPromiscuousMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifPromiscuousMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFPROMISCUOUSMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_IFCONNECTORPRESENT_FLAG) {
       save_flags &= ~COLUMN_IFCONNECTORPRESENT_FLAG; /* clear ifConnectorPresent */
       /*
        * TODO:482:o: |-> commit column ifConnectorPresent.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifConnectorPresent commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifConnectorPresent
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFCONNECTORPRESENT_FLAG;
       }
    }

    if (save_flags & COLUMN_IFALIAS_FLAG) {
       save_flags &= ~COLUMN_IFALIAS_FLAG; /* clear ifAlias */
       /*
        * TODO:482:o: |-> commit column ifAlias.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifAlias commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifAlias
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFALIAS_FLAG;
       }
    }

    if (save_flags & COLUMN_IFCOUNTERDISCONTINUITYTIME_FLAG) {
       save_flags &= ~COLUMN_IFCOUNTERDISCONTINUITYTIME_FLAG; /* clear ifCounterDiscontinuityTime */
       /*
        * TODO:482:o: |-> commit column ifCounterDiscontinuityTime.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ifXTable column ifCounterDiscontinuityTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ifCounterDiscontinuityTime
             */
            rowreq_ctx->column_set_flags |= COLUMN_IFCOUNTERDISCONTINUITYTIME_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* ifXTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ifXTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ifXTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifXTable_undo_commit( ifXTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ifXTable:ifXTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo ifXTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* ifXTable_undo_commit */

/*
 * TODO:440:M: Implement ifXTable node value checks.
 * TODO:450:M: Implement ifXTable undo functions.
 * TODO:460:M: Implement ifXTable set functions.
 * TODO:480:M: Implement ifXTable commit functions.
 */
/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifName
 * ifName is subid 1 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.1
 * Description:
The textual name of the interface.  The value of this
            object should be the name of the interface as assigned by
            the local device and should be suitable for use in commands
            entered at the device's `console'.  This might be a text
            name, such as `le0' or a simple port number, such as `1',
            depending on the interface naming syntax of the device.  If
            several entries in the ifTable together represent a single
            interface as named by the device, then each will have the
            same value of ifName.  Note that for an agent which responds
            to SNMP queries concerning an interface on some other
            (proxied) device, then the value of ifName for such an
            interface is the proxied device's local name for it.

            If there is no local name, or this object is otherwise not
            applicable, then this object contains a zero-length string.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifName_val_ptr
 *        A char containing the new value.
 * @param ifName_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifName_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.ifName).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifName_check_value( ifXTable_rowreq_ctx *rowreq_ctx, char *ifName_val_ptr,  size_t ifName_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ifXTable:ifName_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifName_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ifName value.
     */

    return MFD_SUCCESS; /* ifName value not illegal */
} /* ifName_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifName_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifName_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifName undo.
     */
    /*
     * copy ifName and ifName_len data
     * set rowreq_ctx->undo->ifName from rowreq_ctx->data.ifName
     */
    memcpy( rowreq_ctx->undo->ifName, rowreq_ctx->data.ifName,
            (rowreq_ctx->data.ifName_len * sizeof(rowreq_ctx->undo->ifName[0])));
    rowreq_ctx->undo->ifName_len = rowreq_ctx->data.ifName_len;


    return MFD_SUCCESS;
} /* ifName_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifName_val_ptr
 *        A char containing the new value.
 * @param ifName_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifName_val_ptr
 */
int
ifName_set( ifXTable_rowreq_ctx *rowreq_ctx, char *ifName_val_ptr,  size_t ifName_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ifXTable:ifName_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifName_val_ptr);

    /*
     * TODO:461:M: |-> Set ifName value.
     * set ifName value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ifName, ifName_val_ptr, ifName_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.ifName_len = ifName_val_ptr_len / sizeof(ifName_val_ptr[0]);

    return MFD_SUCCESS;
} /* ifName_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifName_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifName_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifName undo.
     */
    /*
     * copy ifName and ifName_len data
     * set rowreq_ctx->data.ifName from rowreq_ctx->undo->ifName
     */
    memcpy( rowreq_ctx->data.ifName, rowreq_ctx->undo->ifName,
            (rowreq_ctx->undo->ifName_len * sizeof(rowreq_ctx->data.ifName[0])));
    rowreq_ctx->data.ifName_len = rowreq_ctx->undo->ifName_len;

    
    return MFD_SUCCESS;
} /* ifName_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifInMulticastPkts
 * ifInMulticastPkts is subid 2 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.2
 * Description:
The number of packets, delivered by this sub-layer to a
            higher (sub-)layer, which were addressed to a multicast
            address at this sub-layer.  For a MAC layer protocol, this
            includes both Group and Functional addresses.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other

            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInMulticastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInMulticastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifInMulticastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifInMulticastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInMulticastPkts value.
     */

    return MFD_SUCCESS; /* ifInMulticastPkts value not illegal */
} /* ifInMulticastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInMulticastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifInMulticastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInMulticastPkts undo.
     */
    /*
     * copy ifInMulticastPkts data
     * set rowreq_ctx->undo->ifInMulticastPkts from rowreq_ctx->data.ifInMulticastPkts
     */
    rowreq_ctx->undo->ifInMulticastPkts = rowreq_ctx->data.ifInMulticastPkts;


    return MFD_SUCCESS;
} /* ifInMulticastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInMulticastPkts_val
 *        A u_long containing the new value.
 */
int
ifInMulticastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifInMulticastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifInMulticastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInMulticastPkts value.
     * set ifInMulticastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInMulticastPkts = ifInMulticastPkts_val;

    return MFD_SUCCESS;
} /* ifInMulticastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInMulticastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifInMulticastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInMulticastPkts undo.
     */
    /*
     * copy ifInMulticastPkts data
     * set rowreq_ctx->data.ifInMulticastPkts from rowreq_ctx->undo->ifInMulticastPkts
     */
    rowreq_ctx->data.ifInMulticastPkts = rowreq_ctx->undo->ifInMulticastPkts;

    
    return MFD_SUCCESS;
} /* ifInMulticastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifInBroadcastPkts
 * ifInBroadcastPkts is subid 3 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.3
 * Description:
The number of packets, delivered by this sub-layer to a
            higher (sub-)layer, which were addressed to a broadcast
            address at this sub-layer.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInBroadcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifInBroadcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifInBroadcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifInBroadcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifInBroadcastPkts value.
     */

    return MFD_SUCCESS; /* ifInBroadcastPkts value not illegal */
} /* ifInBroadcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifInBroadcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifInBroadcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifInBroadcastPkts undo.
     */
    /*
     * copy ifInBroadcastPkts data
     * set rowreq_ctx->undo->ifInBroadcastPkts from rowreq_ctx->data.ifInBroadcastPkts
     */
    rowreq_ctx->undo->ifInBroadcastPkts = rowreq_ctx->data.ifInBroadcastPkts;


    return MFD_SUCCESS;
} /* ifInBroadcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifInBroadcastPkts_val
 *        A u_long containing the new value.
 */
int
ifInBroadcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifInBroadcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifInBroadcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifInBroadcastPkts value.
     * set ifInBroadcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifInBroadcastPkts = ifInBroadcastPkts_val;

    return MFD_SUCCESS;
} /* ifInBroadcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifInBroadcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifInBroadcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifInBroadcastPkts undo.
     */
    /*
     * copy ifInBroadcastPkts data
     * set rowreq_ctx->data.ifInBroadcastPkts from rowreq_ctx->undo->ifInBroadcastPkts
     */
    rowreq_ctx->data.ifInBroadcastPkts = rowreq_ctx->undo->ifInBroadcastPkts;

    
    return MFD_SUCCESS;
} /* ifInBroadcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifOutMulticastPkts
 * ifOutMulticastPkts is subid 4 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.4
 * Description:
The total number of packets that higher-level protocols
            requested be transmitted, and which were addressed to a
            multicast address at this sub-layer, including those that
            were discarded or not sent.  For a MAC layer protocol, this
            includes both Group and Functional addresses.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutMulticastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutMulticastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifOutMulticastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifOutMulticastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutMulticastPkts value.
     */

    return MFD_SUCCESS; /* ifOutMulticastPkts value not illegal */
} /* ifOutMulticastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutMulticastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifOutMulticastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutMulticastPkts undo.
     */
    /*
     * copy ifOutMulticastPkts data
     * set rowreq_ctx->undo->ifOutMulticastPkts from rowreq_ctx->data.ifOutMulticastPkts
     */
    rowreq_ctx->undo->ifOutMulticastPkts = rowreq_ctx->data.ifOutMulticastPkts;


    return MFD_SUCCESS;
} /* ifOutMulticastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutMulticastPkts_val
 *        A u_long containing the new value.
 */
int
ifOutMulticastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifOutMulticastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifOutMulticastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutMulticastPkts value.
     * set ifOutMulticastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutMulticastPkts = ifOutMulticastPkts_val;

    return MFD_SUCCESS;
} /* ifOutMulticastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutMulticastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifOutMulticastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutMulticastPkts undo.
     */
    /*
     * copy ifOutMulticastPkts data
     * set rowreq_ctx->data.ifOutMulticastPkts from rowreq_ctx->undo->ifOutMulticastPkts
     */
    rowreq_ctx->data.ifOutMulticastPkts = rowreq_ctx->undo->ifOutMulticastPkts;

    
    return MFD_SUCCESS;
} /* ifOutMulticastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifOutBroadcastPkts
 * ifOutBroadcastPkts is subid 5 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.5
 * Description:
The total number of packets that higher-level protocols
            requested be transmitted, and which were addressed to a
            broadcast address at this sub-layer, including those that
            were discarded or not sent.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other

            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutBroadcastPkts_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifOutBroadcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifOutBroadcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifOutBroadcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifOutBroadcastPkts value.
     */

    return MFD_SUCCESS; /* ifOutBroadcastPkts value not illegal */
} /* ifOutBroadcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifOutBroadcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifOutBroadcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifOutBroadcastPkts undo.
     */
    /*
     * copy ifOutBroadcastPkts data
     * set rowreq_ctx->undo->ifOutBroadcastPkts from rowreq_ctx->data.ifOutBroadcastPkts
     */
    rowreq_ctx->undo->ifOutBroadcastPkts = rowreq_ctx->data.ifOutBroadcastPkts;


    return MFD_SUCCESS;
} /* ifOutBroadcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifOutBroadcastPkts_val
 *        A u_long containing the new value.
 */
int
ifOutBroadcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifOutBroadcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifOutBroadcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifOutBroadcastPkts value.
     * set ifOutBroadcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifOutBroadcastPkts = ifOutBroadcastPkts_val;

    return MFD_SUCCESS;
} /* ifOutBroadcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifOutBroadcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifOutBroadcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifOutBroadcastPkts undo.
     */
    /*
     * copy ifOutBroadcastPkts data
     * set rowreq_ctx->data.ifOutBroadcastPkts from rowreq_ctx->undo->ifOutBroadcastPkts
     */
    rowreq_ctx->data.ifOutBroadcastPkts = rowreq_ctx->undo->ifOutBroadcastPkts;

    
    return MFD_SUCCESS;
} /* ifOutBroadcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInOctets
 * ifHCInOctets is subid 6 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.6
 * Description:
The total number of octets received on the interface,
            including framing characters.  This object is a 64-bit
            version of ifInOctets.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInOctets_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCInOctets_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInOctets_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInOctets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCInOctets value.
     */

    return MFD_SUCCESS; /* ifHCInOctets value not illegal */
} /* ifHCInOctets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCInOctets_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInOctets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCInOctets undo.
     */
    /*
     * copy ifHCInOctets data
     * set rowreq_ctx->undo->ifHCInOctets from rowreq_ctx->data.ifHCInOctets
     */
    rowreq_ctx->undo->ifHCInOctets = rowreq_ctx->data.ifHCInOctets;


    return MFD_SUCCESS;
} /* ifHCInOctets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCInOctets_val
 *        A U64 containing the new value.
 */
int
ifHCInOctets_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInOctets_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInOctets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCInOctets value.
     * set ifHCInOctets value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCInOctets = ifHCInOctets_val;

    return MFD_SUCCESS;
} /* ifHCInOctets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCInOctets_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInOctets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCInOctets undo.
     */
    /*
     * copy ifHCInOctets data
     * set rowreq_ctx->data.ifHCInOctets from rowreq_ctx->undo->ifHCInOctets
     */
    rowreq_ctx->data.ifHCInOctets = rowreq_ctx->undo->ifHCInOctets;

    
    return MFD_SUCCESS;
} /* ifHCInOctets_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInUcastPkts
 * ifHCInUcastPkts is subid 7 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.7
 * Description:
The number of packets, delivered by this sub-layer to a
            higher (sub-)layer, which were not addressed to a multicast
            or broadcast address at this sub-layer.  This object is a
            64-bit version of ifInUcastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInUcastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCInUcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCInUcastPkts value.
     */

    return MFD_SUCCESS; /* ifHCInUcastPkts value not illegal */
} /* ifHCInUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCInUcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCInUcastPkts undo.
     */
    /*
     * copy ifHCInUcastPkts data
     * set rowreq_ctx->undo->ifHCInUcastPkts from rowreq_ctx->data.ifHCInUcastPkts
     */
    rowreq_ctx->undo->ifHCInUcastPkts = rowreq_ctx->data.ifHCInUcastPkts;


    return MFD_SUCCESS;
} /* ifHCInUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCInUcastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCInUcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCInUcastPkts value.
     * set ifHCInUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCInUcastPkts = ifHCInUcastPkts_val;

    return MFD_SUCCESS;
} /* ifHCInUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCInUcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCInUcastPkts undo.
     */
    /*
     * copy ifHCInUcastPkts data
     * set rowreq_ctx->data.ifHCInUcastPkts from rowreq_ctx->undo->ifHCInUcastPkts
     */
    rowreq_ctx->data.ifHCInUcastPkts = rowreq_ctx->undo->ifHCInUcastPkts;

    
    return MFD_SUCCESS;
} /* ifHCInUcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInMulticastPkts
 * ifHCInMulticastPkts is subid 8 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.8
 * Description:
The number of packets, delivered by this sub-layer to a
            higher (sub-)layer, which were addressed to a multicast
            address at this sub-layer.  For a MAC layer protocol, this
            includes both Group and Functional addresses.  This object
            is a 64-bit version of ifInMulticastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInMulticastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCInMulticastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInMulticastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInMulticastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCInMulticastPkts value.
     */

    return MFD_SUCCESS; /* ifHCInMulticastPkts value not illegal */
} /* ifHCInMulticastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCInMulticastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInMulticastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCInMulticastPkts undo.
     */
    /*
     * copy ifHCInMulticastPkts data
     * set rowreq_ctx->undo->ifHCInMulticastPkts from rowreq_ctx->data.ifHCInMulticastPkts
     */
    rowreq_ctx->undo->ifHCInMulticastPkts = rowreq_ctx->data.ifHCInMulticastPkts;


    return MFD_SUCCESS;
} /* ifHCInMulticastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCInMulticastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCInMulticastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInMulticastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInMulticastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCInMulticastPkts value.
     * set ifHCInMulticastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCInMulticastPkts = ifHCInMulticastPkts_val;

    return MFD_SUCCESS;
} /* ifHCInMulticastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCInMulticastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInMulticastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCInMulticastPkts undo.
     */
    /*
     * copy ifHCInMulticastPkts data
     * set rowreq_ctx->data.ifHCInMulticastPkts from rowreq_ctx->undo->ifHCInMulticastPkts
     */
    rowreq_ctx->data.ifHCInMulticastPkts = rowreq_ctx->undo->ifHCInMulticastPkts;

    
    return MFD_SUCCESS;
} /* ifHCInMulticastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInBroadcastPkts
 * ifHCInBroadcastPkts is subid 9 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.9
 * Description:
The number of packets, delivered by this sub-layer to a
            higher (sub-)layer, which were addressed to a broadcast
            address at this sub-layer.  This object is a 64-bit version
            of ifInBroadcastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInBroadcastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCInBroadcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInBroadcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInBroadcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCInBroadcastPkts value.
     */

    return MFD_SUCCESS; /* ifHCInBroadcastPkts value not illegal */
} /* ifHCInBroadcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCInBroadcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCInBroadcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCInBroadcastPkts undo.
     */
    /*
     * copy ifHCInBroadcastPkts data
     * set rowreq_ctx->undo->ifHCInBroadcastPkts from rowreq_ctx->data.ifHCInBroadcastPkts
     */
    rowreq_ctx->undo->ifHCInBroadcastPkts = rowreq_ctx->data.ifHCInBroadcastPkts;


    return MFD_SUCCESS;
} /* ifHCInBroadcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCInBroadcastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCInBroadcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCInBroadcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInBroadcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCInBroadcastPkts value.
     * set ifHCInBroadcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCInBroadcastPkts = ifHCInBroadcastPkts_val;

    return MFD_SUCCESS;
} /* ifHCInBroadcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCInBroadcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCInBroadcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCInBroadcastPkts undo.
     */
    /*
     * copy ifHCInBroadcastPkts data
     * set rowreq_ctx->data.ifHCInBroadcastPkts from rowreq_ctx->undo->ifHCInBroadcastPkts
     */
    rowreq_ctx->data.ifHCInBroadcastPkts = rowreq_ctx->undo->ifHCInBroadcastPkts;

    
    return MFD_SUCCESS;
} /* ifHCInBroadcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutOctets
 * ifHCOutOctets is subid 10 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.10
 * Description:
The total number of octets transmitted out of the
            interface, including framing characters.  This object is a
            64-bit version of ifOutOctets.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutOctets_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCOutOctets_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutOctets_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutOctets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCOutOctets value.
     */

    return MFD_SUCCESS; /* ifHCOutOctets value not illegal */
} /* ifHCOutOctets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCOutOctets_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutOctets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCOutOctets undo.
     */
    /*
     * copy ifHCOutOctets data
     * set rowreq_ctx->undo->ifHCOutOctets from rowreq_ctx->data.ifHCOutOctets
     */
    rowreq_ctx->undo->ifHCOutOctets = rowreq_ctx->data.ifHCOutOctets;


    return MFD_SUCCESS;
} /* ifHCOutOctets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCOutOctets_val
 *        A U64 containing the new value.
 */
int
ifHCOutOctets_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutOctets_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutOctets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCOutOctets value.
     * set ifHCOutOctets value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCOutOctets = ifHCOutOctets_val;

    return MFD_SUCCESS;
} /* ifHCOutOctets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCOutOctets_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutOctets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCOutOctets undo.
     */
    /*
     * copy ifHCOutOctets data
     * set rowreq_ctx->data.ifHCOutOctets from rowreq_ctx->undo->ifHCOutOctets
     */
    rowreq_ctx->data.ifHCOutOctets = rowreq_ctx->undo->ifHCOutOctets;

    
    return MFD_SUCCESS;
} /* ifHCOutOctets_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutUcastPkts
 * ifHCOutUcastPkts is subid 11 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.11
 * Description:
The total number of packets that higher-level protocols
            requested be transmitted, and which were not addressed to a
            multicast or broadcast address at this sub-layer, including
            those that were discarded or not sent.  This object is a
            64-bit version of ifOutUcastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutUcastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCOutUcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutUcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutUcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCOutUcastPkts value.
     */

    return MFD_SUCCESS; /* ifHCOutUcastPkts value not illegal */
} /* ifHCOutUcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCOutUcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutUcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCOutUcastPkts undo.
     */
    /*
     * copy ifHCOutUcastPkts data
     * set rowreq_ctx->undo->ifHCOutUcastPkts from rowreq_ctx->data.ifHCOutUcastPkts
     */
    rowreq_ctx->undo->ifHCOutUcastPkts = rowreq_ctx->data.ifHCOutUcastPkts;


    return MFD_SUCCESS;
} /* ifHCOutUcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCOutUcastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCOutUcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutUcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutUcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCOutUcastPkts value.
     * set ifHCOutUcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCOutUcastPkts = ifHCOutUcastPkts_val;

    return MFD_SUCCESS;
} /* ifHCOutUcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCOutUcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutUcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCOutUcastPkts undo.
     */
    /*
     * copy ifHCOutUcastPkts data
     * set rowreq_ctx->data.ifHCOutUcastPkts from rowreq_ctx->undo->ifHCOutUcastPkts
     */
    rowreq_ctx->data.ifHCOutUcastPkts = rowreq_ctx->undo->ifHCOutUcastPkts;

    
    return MFD_SUCCESS;
} /* ifHCOutUcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutMulticastPkts
 * ifHCOutMulticastPkts is subid 12 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.12
 * Description:
The total number of packets that higher-level protocols
            requested be transmitted, and which were addressed to a
            multicast address at this sub-layer, including those that
            were discarded or not sent.  For a MAC layer protocol, this
            includes both Group and Functional addresses.  This object
            is a 64-bit version of ifOutMulticastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutMulticastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCOutMulticastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutMulticastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutMulticastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCOutMulticastPkts value.
     */

    return MFD_SUCCESS; /* ifHCOutMulticastPkts value not illegal */
} /* ifHCOutMulticastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCOutMulticastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutMulticastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCOutMulticastPkts undo.
     */
    /*
     * copy ifHCOutMulticastPkts data
     * set rowreq_ctx->undo->ifHCOutMulticastPkts from rowreq_ctx->data.ifHCOutMulticastPkts
     */
    rowreq_ctx->undo->ifHCOutMulticastPkts = rowreq_ctx->data.ifHCOutMulticastPkts;


    return MFD_SUCCESS;
} /* ifHCOutMulticastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCOutMulticastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCOutMulticastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutMulticastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutMulticastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCOutMulticastPkts value.
     * set ifHCOutMulticastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCOutMulticastPkts = ifHCOutMulticastPkts_val;

    return MFD_SUCCESS;
} /* ifHCOutMulticastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCOutMulticastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutMulticastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCOutMulticastPkts undo.
     */
    /*
     * copy ifHCOutMulticastPkts data
     * set rowreq_ctx->data.ifHCOutMulticastPkts from rowreq_ctx->undo->ifHCOutMulticastPkts
     */
    rowreq_ctx->data.ifHCOutMulticastPkts = rowreq_ctx->undo->ifHCOutMulticastPkts;

    
    return MFD_SUCCESS;
} /* ifHCOutMulticastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutBroadcastPkts
 * ifHCOutBroadcastPkts is subid 13 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.13
 * Description:
The total number of packets that higher-level protocols
            requested be transmitted, and which were addressed to a
            broadcast address at this sub-layer, including those that
            were discarded or not sent.  This object is a 64-bit version
            of ifOutBroadcastPkts.

            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ifCounterDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutBroadcastPkts_val
 *        A U64 containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHCOutBroadcastPkts_check_value( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutBroadcastPkts_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutBroadcastPkts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHCOutBroadcastPkts value.
     */

    return MFD_SUCCESS; /* ifHCOutBroadcastPkts value not illegal */
} /* ifHCOutBroadcastPkts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHCOutBroadcastPkts_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHCOutBroadcastPkts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHCOutBroadcastPkts undo.
     */
    /*
     * copy ifHCOutBroadcastPkts data
     * set rowreq_ctx->undo->ifHCOutBroadcastPkts from rowreq_ctx->data.ifHCOutBroadcastPkts
     */
    rowreq_ctx->undo->ifHCOutBroadcastPkts = rowreq_ctx->data.ifHCOutBroadcastPkts;


    return MFD_SUCCESS;
} /* ifHCOutBroadcastPkts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHCOutBroadcastPkts_val
 *        A U64 containing the new value.
 */
int
ifHCOutBroadcastPkts_set( ifXTable_rowreq_ctx *rowreq_ctx, U64 ifHCOutBroadcastPkts_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutBroadcastPkts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHCOutBroadcastPkts value.
     * set ifHCOutBroadcastPkts value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHCOutBroadcastPkts = ifHCOutBroadcastPkts_val;

    return MFD_SUCCESS;
} /* ifHCOutBroadcastPkts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHCOutBroadcastPkts_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHCOutBroadcastPkts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHCOutBroadcastPkts undo.
     */
    /*
     * copy ifHCOutBroadcastPkts data
     * set rowreq_ctx->data.ifHCOutBroadcastPkts from rowreq_ctx->undo->ifHCOutBroadcastPkts
     */
    rowreq_ctx->data.ifHCOutBroadcastPkts = rowreq_ctx->undo->ifHCOutBroadcastPkts;

    
    return MFD_SUCCESS;
} /* ifHCOutBroadcastPkts_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifLinkUpDownTrapEnable
 * ifLinkUpDownTrapEnable is subid 14 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.14
 * Description:
Indicates whether linkUp/linkDown traps should be generated
            for this interface.

            By default, this object should have the value enabled(1) for
            interfaces which do not operate on 'top' of any other
            interface (as defined in the ifStackTable), and disabled(2)
            otherwise.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 1/8. Values:  enabled(1), disabled(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifLinkUpDownTrapEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  enabled(1), disabled(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifLinkUpDownTrapEnable_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifLinkUpDownTrapEnable_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifLinkUpDownTrapEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifLinkUpDownTrapEnable value.
     */

    return MFD_SUCCESS; /* ifLinkUpDownTrapEnable value not illegal */
} /* ifLinkUpDownTrapEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifLinkUpDownTrapEnable_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifLinkUpDownTrapEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifLinkUpDownTrapEnable undo.
     */
    /*
     * copy ifLinkUpDownTrapEnable data
     * set rowreq_ctx->undo->ifLinkUpDownTrapEnable from rowreq_ctx->data.ifLinkUpDownTrapEnable
     */
    rowreq_ctx->undo->ifLinkUpDownTrapEnable = rowreq_ctx->data.ifLinkUpDownTrapEnable;


    return MFD_SUCCESS;
} /* ifLinkUpDownTrapEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifLinkUpDownTrapEnable_val
 *        A long containing the new value.
 */
int
ifLinkUpDownTrapEnable_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifLinkUpDownTrapEnable_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifLinkUpDownTrapEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifLinkUpDownTrapEnable value.
     * set ifLinkUpDownTrapEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifLinkUpDownTrapEnable = ifLinkUpDownTrapEnable_val;

    return MFD_SUCCESS;
} /* ifLinkUpDownTrapEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifLinkUpDownTrapEnable_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifLinkUpDownTrapEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifLinkUpDownTrapEnable undo.
     */
    /*
     * copy ifLinkUpDownTrapEnable data
     * set rowreq_ctx->data.ifLinkUpDownTrapEnable from rowreq_ctx->undo->ifLinkUpDownTrapEnable
     */
    rowreq_ctx->data.ifLinkUpDownTrapEnable = rowreq_ctx->undo->ifLinkUpDownTrapEnable;

    
    return MFD_SUCCESS;
} /* ifLinkUpDownTrapEnable_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHighSpeed
 * ifHighSpeed is subid 15 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.15
 * Description:
An estimate of the interface's current bandwidth in units
            of 1,000,000 bits per second.  If this object reports a
            value of `n' then the speed of the interface is somewhere in
            the range of `n-500,000' to `n+499,999'.  For interfaces
            which do not vary in bandwidth or for those where no
            accurate estimation can be made, this object should contain
            the nominal bandwidth.  For a sub-layer which has no concept
            of bandwidth, this object should be zero.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHighSpeed_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_GAUGE
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifHighSpeed_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifHighSpeed_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHighSpeed_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifHighSpeed value.
     */

    return MFD_SUCCESS; /* ifHighSpeed value not illegal */
} /* ifHighSpeed_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifHighSpeed_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifHighSpeed_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifHighSpeed undo.
     */
    /*
     * copy ifHighSpeed data
     * set rowreq_ctx->undo->ifHighSpeed from rowreq_ctx->data.ifHighSpeed
     */
    rowreq_ctx->undo->ifHighSpeed = rowreq_ctx->data.ifHighSpeed;


    return MFD_SUCCESS;
} /* ifHighSpeed_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifHighSpeed_val
 *        A u_long containing the new value.
 */
int
ifHighSpeed_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifHighSpeed_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifHighSpeed_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifHighSpeed value.
     * set ifHighSpeed value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifHighSpeed = ifHighSpeed_val;

    return MFD_SUCCESS;
} /* ifHighSpeed_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifHighSpeed_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifHighSpeed_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifHighSpeed undo.
     */
    /*
     * copy ifHighSpeed data
     * set rowreq_ctx->data.ifHighSpeed from rowreq_ctx->undo->ifHighSpeed
     */
    rowreq_ctx->data.ifHighSpeed = rowreq_ctx->undo->ifHighSpeed;

    
    return MFD_SUCCESS;
} /* ifHighSpeed_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifPromiscuousMode
 * ifPromiscuousMode is subid 16 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.16
 * Description:
This object has a value of false(2) if this interface only
            accepts packets/frames that are addressed to this station.
            This object has a value of true(1) when the station accepts
            all packets/frames transmitted on the media.  The value
            true(1) is only legal on certain types of media.  If legal,
            setting this object to a value of true(1) may require the
            interface to be reset before becoming effective.

            The value of ifPromiscuousMode does not affect the reception
            of broadcast and multicast packets/frames by the interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifPromiscuousMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifPromiscuousMode_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifPromiscuousMode_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifPromiscuousMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifPromiscuousMode value.
     */

    return MFD_SUCCESS; /* ifPromiscuousMode value not illegal */
} /* ifPromiscuousMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifPromiscuousMode_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifPromiscuousMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifPromiscuousMode undo.
     */
    /*
     * copy ifPromiscuousMode data
     * set rowreq_ctx->undo->ifPromiscuousMode from rowreq_ctx->data.ifPromiscuousMode
     */
    rowreq_ctx->undo->ifPromiscuousMode = rowreq_ctx->data.ifPromiscuousMode;


    return MFD_SUCCESS;
} /* ifPromiscuousMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifPromiscuousMode_val
 *        A long containing the new value.
 */
int
ifPromiscuousMode_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifPromiscuousMode_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifPromiscuousMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifPromiscuousMode value.
     * set ifPromiscuousMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifPromiscuousMode = ifPromiscuousMode_val;

    return MFD_SUCCESS;
} /* ifPromiscuousMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifPromiscuousMode_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifPromiscuousMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifPromiscuousMode undo.
     */
    /*
     * copy ifPromiscuousMode data
     * set rowreq_ctx->data.ifPromiscuousMode from rowreq_ctx->undo->ifPromiscuousMode
     */
    rowreq_ctx->data.ifPromiscuousMode = rowreq_ctx->undo->ifPromiscuousMode;

    
    return MFD_SUCCESS;
} /* ifPromiscuousMode_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifConnectorPresent
 * ifConnectorPresent is subid 17 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.17
 * Description:
This object has the value 'true(1)' if the interface
            sublayer has a physical connector and the value 'false(2)'
            otherwise.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifConnectorPresent_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifConnectorPresent_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifConnectorPresent_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifConnectorPresent_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifConnectorPresent value.
     */

    return MFD_SUCCESS; /* ifConnectorPresent value not illegal */
} /* ifConnectorPresent_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifConnectorPresent_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifConnectorPresent_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifConnectorPresent undo.
     */
    /*
     * copy ifConnectorPresent data
     * set rowreq_ctx->undo->ifConnectorPresent from rowreq_ctx->data.ifConnectorPresent
     */
    rowreq_ctx->undo->ifConnectorPresent = rowreq_ctx->data.ifConnectorPresent;


    return MFD_SUCCESS;
} /* ifConnectorPresent_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifConnectorPresent_val
 *        A long containing the new value.
 */
int
ifConnectorPresent_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifConnectorPresent_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifConnectorPresent_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifConnectorPresent value.
     * set ifConnectorPresent value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifConnectorPresent = ifConnectorPresent_val;

    return MFD_SUCCESS;
} /* ifConnectorPresent_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifConnectorPresent_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifConnectorPresent_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifConnectorPresent undo.
     */
    /*
     * copy ifConnectorPresent data
     * set rowreq_ctx->data.ifConnectorPresent from rowreq_ctx->undo->ifConnectorPresent
     */
    rowreq_ctx->data.ifConnectorPresent = rowreq_ctx->undo->ifConnectorPresent;

    
    return MFD_SUCCESS;
} /* ifConnectorPresent_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifAlias
 * ifAlias is subid 18 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.18
 * Description:
This object is an 'alias' name for the interface as
            specified by a network manager, and provides a non-volatile
            'handle' for the interface.

            On the first instantiation of an interface, the value of
            ifAlias associated with that interface is the zero-length
            string.  As and when a value is written into an instance of
            ifAlias through a network management set operation, then the
            agent must retain the supplied value in the ifAlias instance
            associated with the same interface for as long as that
            interface remains instantiated, including across all re-
            initializations/reboots of the network management system,
            including those which result in a change of the interface's
            ifIndex value.

            An example of the value which a network manager might store
            in this object for a WAN interface is the (Telco's) circuit
            number/identifier of the interface.

            Some agents may support write-access only for interfaces
            having particular values of ifType.  An agent which supports
            write access to this object is required to keep the value in
            non-volatile storage, but it may limit the length of new
            values depending on how much storage is already occupied by
            the current values for other interfaces.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifAlias_val_ptr
 *        A char containing the new value.
 * @param ifAlias_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifAlias_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.ifAlias).
 *    The length is in (one of) the range set(s):  0 - 64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifAlias_check_value( ifXTable_rowreq_ctx *rowreq_ctx, char *ifAlias_val_ptr,  size_t ifAlias_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ifXTable:ifAlias_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifAlias_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ifAlias value.
     */

    return MFD_SUCCESS; /* ifAlias value not illegal */
} /* ifAlias_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifAlias_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifAlias_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifAlias undo.
     */
    /*
     * copy ifAlias and ifAlias_len data
     * set rowreq_ctx->undo->ifAlias from rowreq_ctx->data.ifAlias
     */
    memcpy( rowreq_ctx->undo->ifAlias, rowreq_ctx->data.ifAlias,
            (rowreq_ctx->data.ifAlias_len * sizeof(rowreq_ctx->undo->ifAlias[0])));
    rowreq_ctx->undo->ifAlias_len = rowreq_ctx->data.ifAlias_len;


    return MFD_SUCCESS;
} /* ifAlias_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifAlias_val_ptr
 *        A char containing the new value.
 * @param ifAlias_val_ptr_len
 *        The size (in bytes) of the data pointed to by ifAlias_val_ptr
 */
int
ifAlias_set( ifXTable_rowreq_ctx *rowreq_ctx, char *ifAlias_val_ptr,  size_t ifAlias_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ifXTable:ifAlias_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifAlias_val_ptr);

    /*
     * TODO:461:M: |-> Set ifAlias value.
     * set ifAlias value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ifAlias, ifAlias_val_ptr, ifAlias_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.ifAlias_len = ifAlias_val_ptr_len / sizeof(ifAlias_val_ptr[0]);

    return MFD_SUCCESS;
} /* ifAlias_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifAlias_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifAlias_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifAlias undo.
     */
    /*
     * copy ifAlias and ifAlias_len data
     * set rowreq_ctx->data.ifAlias from rowreq_ctx->undo->ifAlias
     */
    memcpy( rowreq_ctx->data.ifAlias, rowreq_ctx->undo->ifAlias,
            (rowreq_ctx->undo->ifAlias_len * sizeof(rowreq_ctx->data.ifAlias[0])));
    rowreq_ctx->data.ifAlias_len = rowreq_ctx->undo->ifAlias_len;

    
    return MFD_SUCCESS;
} /* ifAlias_undo */

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifCounterDiscontinuityTime
 * ifCounterDiscontinuityTime is subid 19 of ifXEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.19
 * Description:
The value of sysUpTime on the most recent occasion at which
            any one or more of this interface's counters suffered a
            discontinuity.  The relevant counters are the specific
            instances associated with this interface of any Counter32 or

            Counter64 object contained in the ifTable or ifXTable.  If
            no such discontinuities have occurred since the last re-
            initialization of the local management subsystem, then this
            object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifCounterDiscontinuityTime_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_TIMETICKS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ifCounterDiscontinuityTime_check_value( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifCounterDiscontinuityTime_val)
{
    DEBUGMSGTL(("verbose:ifXTable:ifCounterDiscontinuityTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ifCounterDiscontinuityTime value.
     */

    return MFD_SUCCESS; /* ifCounterDiscontinuityTime value not illegal */
} /* ifCounterDiscontinuityTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifCounterDiscontinuityTime_undo_setup( ifXTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifXTable:ifCounterDiscontinuityTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ifCounterDiscontinuityTime undo.
     */
    /*
     * copy ifCounterDiscontinuityTime data
     * set rowreq_ctx->undo->ifCounterDiscontinuityTime from rowreq_ctx->data.ifCounterDiscontinuityTime
     */
    rowreq_ctx->undo->ifCounterDiscontinuityTime = rowreq_ctx->data.ifCounterDiscontinuityTime;


    return MFD_SUCCESS;
} /* ifCounterDiscontinuityTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifCounterDiscontinuityTime_val
 *        A u_long containing the new value.
 */
int
ifCounterDiscontinuityTime_set( ifXTable_rowreq_ctx *rowreq_ctx, u_long ifCounterDiscontinuityTime_val )
{

    DEBUGMSGTL(("verbose:ifXTable:ifCounterDiscontinuityTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ifCounterDiscontinuityTime value.
     * set ifCounterDiscontinuityTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.ifCounterDiscontinuityTime = ifCounterDiscontinuityTime_val;

    return MFD_SUCCESS;
} /* ifCounterDiscontinuityTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifCounterDiscontinuityTime_undo( ifXTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ifXTable:ifCounterDiscontinuityTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ifCounterDiscontinuityTime undo.
     */
    /*
     * copy ifCounterDiscontinuityTime data
     * set rowreq_ctx->data.ifCounterDiscontinuityTime from rowreq_ctx->undo->ifCounterDiscontinuityTime
     */
    rowreq_ctx->data.ifCounterDiscontinuityTime = rowreq_ctx->undo->ifCounterDiscontinuityTime;

    
    return MFD_SUCCESS;
} /* ifCounterDiscontinuityTime_undo */

/** @} */
